---
layout: post
title: "고성능 애니메이션 및 마이크로 인터랙션을 디자인하는 방법
 "
author: 'Code Tower'
thumbnail: https://blog.logrocket.com/wp-content/uploads/2021/01/highly_performant_animations.png
tags: undefined
---


![image](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/highly_performant_animations.png?fit=730%2C487&ssl=1)

애니메이션은 더 환영하고 매력적인 사용자 경험을 만드는 데 도움이 될 수 있습니다.
 브랜드에 대한 사용자 인식과 기억을 향상시킬 수 있습니다.
 그러나 고품질 애니메이션을 추가하는 것이 항상 쉬운 일은 아닙니다.
 여기저기서 애니메이션을 뿌릴 수는 없습니다!
 

웹 사이트가 엘리베이터 피치라고 가정 해 보겠습니다. 사용자를 끌어들일 시간이 짧고 지연이 발생하면 사람들이 기다리지 않을 것입니다.
 웹 사이트는 빠르기 때문에 느린 애니메이션은 절대 안됩니다.
 

오늘은 고성능 애니메이션을 만드는 방법에 대해 설명하겠습니다.
 

## 웹 사이트 속도가 중요한 이유
 

Google이 의뢰 한 새로운 연구에서 모바일 웹 사이트 속도가 비즈니스에 미치는 영향을 조사했습니다.
 결과는 속도와 사용자 경험 (UX)이 얼마나 밀접하게 연결되어 있는지 보여줍니다.
 

> 속도는 사용자 경험에 직접적인 영향을 미칩니다.
 속도는 모든 디지털 이니셔티브의 성공에 중요한 역할을하며 전자 상거래 및 기타 거래 사이트에서 두드러집니다.
 소비자의 70 %는 페이지 속도가 온라인 소매 업체에서 구매하려는 의지에 영향을 미친다는 사실을 인정하며, 미국에서는 지연 시간이 소비자가 모바일 사이트를 포기하기로 결정한 가장 큰 이유이며, 10 %는 느린 다운로드를 구매하지 않은 이유로 탓합니다.
Milliseconds는 Deloitte와 55의 Millions Report를 만듭니다.
 

이 연구에 따르면 사이트 속도가 100ms 향상되면 소매 소비자가 거의 10 % 더 많이 소비하게됩니다.
 또한 고급 소비자는 페이지 조회수가 8 % 증가하면서 더 많이 참여했습니다.
 

판돈이 높습니다!
 

![image](https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/experiences-graphs.png?resize=730%2C296&ssl=1)

사이트 속도는 또한 검색 엔진 뒤에있는 회사가 요소 속도가 정확히 얼마나 중요한지에 대해 밝히지 않더라도 웹 사이트 순위를 매기는 검색 엔진에 큰 요소입니다.
 

## 웹 사이트 접근성이 디자인에 미치는 영향
 

사람들은 같은 방식으로 웹 사이트에 액세스하지 않습니다.
 장치는 다양합니다.
 인터넷 속도는 다양합니다.
 브라우징 습관은 다양합니다.
 동일한 웹 사이트는 사용자의 상황에 따라 다르게 경험됩니다.
 모든 사람이 웹 사이트에서 좋은 경험을 할 수 있도록하려면 저속 연결과 구형 장치에 맞게 디자인해야합니다.
 

웹 연감은 웹 보고서의 연간 상태를 수행합니다.
 2020 년 보고서의 성능 결과에 따르면 빠른 웹 사이트에 설정된 목표를 달성하기 위해해야 할 일이 많지만 낙관적 인 이유가 있습니다.
 

그 과정에서 이러한 사실을 간과하거나 잊지 않는 것이 중요합니다.
 

## RAIL을 사용하여 주요 지표 타겟팅
 

Google에는 RAIL이라는 사용자 중심 성능 모델이 있습니다.
 RAIL은 웹 앱 수명주기의 네 가지 고유 한 측면 인 응답, 애니메이션, 유휴 및로드를 나타냅니다.
 

RAIL은 특정 성능 목표를 설정하고이를 달성하는 방법에 대한 지침을 제공합니다.
 

성능 목표는 다음과 같습니다.
 

- 응답 : 50ms 이내에 이벤트 처리
 
- 애니메이션 : 프레임 속도가 다를 때 사용자가 알아 차리기 때문에 10ms 내에 프레임을 생성하고 시각적 부드러움을 목표로
 
- 유휴 : 유휴 시간을 최대화하여 페이지가 50ms 이내에 사용자 입력에 응답 할 확률을 높입니다.
 
- 로드 : 5 초 이내에 콘텐츠를 전달하고 상호 작용할 수 있습니다.
 

애니메이션 성능 목표를 더 자세히 살펴 보겠습니다.
 기술적으로 각 프레임의 최대 예산은 16ms (초당 1000ms / 60 프레임 ≈16ms)이지만 브라우저는 각 프레임을 렌더링하는 데 약 6ms가 필요하므로 프레임 당 10ms의 지침이 필요합니다.
 왜 초당 60 프레임입니까?
 

화면이 새로 고침 될 때마다 새 프레임을 만들면 부드럽게 움직입니다.
 일반적인 장치 새로 고침 빈도는 60Hz (헤르츠)이며, 이는 화면이 초당 60 회 새로 고쳐 짐을 의미합니다.
 

그러나 다른 재생률에서 60fps로 실행하려면 적은 시간에 렌더링 할 프레임이 필요합니다.
 

- 60Hz에서 : 16.67ms
 
- 90Hz에서 : 11.11ms (예 : Google Pixel 5 2020)
 
- 120Hz에서 : 8.33ms (예 : Apple iPad Pro 11 2020)
 
- 144Hz에서 : 6.94ms (예 : 데스크톱 모니터)
 

이것은 장치의 차이를 고려할 때 충족하기 어려운 표준입니다.
 화면의 새로 고침 빈도뿐만 아니라 분명히 장치의 속도에 관한 것입니다.
 가장 느린 장치에서는 60fps가 도달 할 수 없습니다.
 

최우선 순위는 버벅 거림을 방지하는 것입니다. 즉, 지연되거나 불안정한 움직임을 만드는 모든 것입니다.
 우리가 추구하는 것은 효율적이고 프레임 속도를 가능한 한 높게 유지하는 것입니다.
 

노력해야 할 또 다른 중요한 메트릭은 일관된 프레임 속도입니다.
 변동은 사용자에게 말더듬으로 표시됩니다.
 Google은 최근 ADF (Average Dropped Frame)라는 새로운 메트릭을 도입했습니다.
 ADF는 웹 페이지의 GPU 및 렌더링 성능을 측정하는 평활도 측정 항목입니다.
 ADF가 낮을수록 페이지가 더 부드러워집니다.
 이것은 우리가 모니터링해야하는 또 다른 주요 지표입니다.
 

사용자 상호 작용의 경우 100 밀리 초 이내의 응답 시간은 결과가 즉각적인 것처럼 느껴집니다.
 애니메이션을 트리거하는 대상이어야합니다.
 100ms 이내에 가시적 인 응답을 제공하려면 사용자 입력 이벤트를 50ms 이내에 처리해야합니다.
 

![image](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/trigger-animation.png?resize=730%2C486&ssl=1)

응답 시간이 100ms보다 길면 사용자가 약간의 지연을 감지합니다.
 이 경우 진행률 표시 줄과 같은 피드백을 사용자에게 제공해야합니다.
 

애니메이션이 웹 페이지의 전반적인 성능에 어떻게 부합하는지 고려해야합니다.
 성능 예산 설정은 디자인 관련 의사 결정에 매우 유용합니다.
 중요한 페이지 메트릭에 대해 허용 가능한 값이 포함 된 간단한 JSON 파일을 사용하여 Lighthouse 도구에서 성능 예산을 만들 수 있습니다.
 페이지가로드 될 때 애니메이션이 비활성 상태이거나 화면 밖에있는 경우 애니메이션이 이러한 측정 항목에 미치는 영향이 훨씬 적습니다.
 

## 렌더링 개선을위한 알고리즘
 

프레임을 렌더링하기 위해 주요 브라우저가 따르는 일반적인 알고리즘이 있습니다.
 Google은이를 픽셀 파이프 라인이라고합니다.
 Mozilla는이를 렌더링 폭포라고 부릅니다.
 

![image](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/rendering-waterfall.png?resize=730%2C486&ssl=1)

알고리즘의 각 단계는 다음에 오는 단계를 트리거합니다.
 

- JavaScript : JavaScript는 DOM 또는 CSSOM이 변경된 경우 시각적 변경을 트리거합니다.
 
- 스타일 계산 : 브라우저가 페이지 요소에 대해 계산 된 스타일이 변경되었다고 생각하면이를 다시 계산해야합니다.
 
- 레이아웃 : 레이아웃은 계산 된 스타일을 기반으로 각 요소의 크기와 위치를 결정합니다.
 Mozilla에서는 "리플 로우"라고도합니다.
 
- 페인트 : 페인팅은 각 요소의 픽셀을 레이어에 채 웁니다.
 아직 화면에 이러한 레이어를 그리지 않습니다.
 
- 컴포지션 : 칠해진 레이어를 올바른 순서로 화면에 그립니다.
 

브라우저는 매번 각 단계를 거칠 필요가 없습니다.
 변경시 페인트 만 수행하면되는 경우 레이아웃 단계를 건너 뜁니다.
 

짐작할 수 있듯이 브라우저가 프레임을 렌더링하는 데 필요한 단계가 적 으면 성능이 향상됩니다.
 어떤 유형의 변경이 다른 단계를 유발하는지 이해한다면 애니메이션을 만들 때 더 나은 결정을 내릴 수 있습니다.
 

Google은 CSS 트리거라는 작은 웹 사이트를 만들었습니다.이 웹 사이트는 그들이 트리거하는 렌더링 단계와 함께 CSS 속성을 나열합니다.
 몇 년 동안 업데이트되지 않았기 때문에 정확성이 의심 스럽습니다.
 대략적인 아이디어를 얻기 위해 그것을 볼 수 있습니다.
 

## 고성능 애니메이션 및 마이크로 인터랙션 디자인
 

우선 우리가 규칙을 만들고 싶지 않다고 말하는 것이 중요합니다.
 규칙을 따르면 매번 올바른 결과를 얻을 수 있습니다.
 그런 식으로 작동하지 않습니다!
 물론 당신이하는 일의 맥락이 중요합니다.
 그리고 브라우저 내부가 변화함에 따라 시간이 지남에 따라 상황이 바뀝니다.
 

건전한 디자인 결정을 내리는 데 도움이되는 일련의 디자인 휴리스틱을 사용하는 것이 좋습니다.
 그들에게 겁을 주어서는 안됩니다. 그들은 함정을 피할 수 있도록 도와줍니다.
 DevTools를 사용하여 수행중인 작업을 검증하는 과정에서 성능을 측정해야합니다.
 

CSS, JavaScript 또는 JavaScript 라이브러리 사용을 옹호하지 않습니다.
 이들 모두에서 유사한 성능을 얻을 수 있습니다.
 그 진술에는 많은 뉘앙스와 맥락이 있지만 여기서 다루지 않을 다른 대화입니다.
 

그럼 우리의 디자인 휴리스틱을 다룰 것입니다.
 

### 1. 컴포지션 속성 '변형'및 '불투명도'애니메이션을 고수하십시오.
 

렌더링 알고리즘의 합성 단계에만 영향을 미치는 속성을 사용하면 최상의 성능을 얻을 수 있습니다.
 `transform` 및`opacity` 속성이이 범주에 속합니다.
 

이러한 속성에 대한 렌더링은 GPU로 오프로드 될 수 있지만주의 할 점은 요소가 자체 레이어에 있어야한다는 것입니다.
 경우에 따라 브라우저에 의해 요소가 자동으로 레이어로 승격되지만 직접 트리거 할 수도 있습니다.
 

![image](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/star-wars-animation.gif?resize=369%2C476&ssl=1)

예를 들어,이 Star Wars 애니메이션에는 효과적으로 3 개의 레이어가 있습니다.
 

![image](https://i0.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/star-wars-layers.png?resize=730%2C482&ssl=1)

요소를 레이어로 어떻게 승격합니까?
 

- CSS에서 :`will-change` 속성을 설정할 수 있습니다.
 `will-change`를 지원하지 않는 이전 브라우저의 경우 요소에`transform : translateZ (0);`을 해킹으로 추가 할 수 있습니다.
 
- JavaScript에서 :`translate3d ()`및`matrix3d ()`와 같은 3D 특성으로 변환을 설정하면 레이어가 생성됩니다.
 일부 JavaScript 라이브러리가 내부적으로이 작업을 수행한다는 것을 알 수 있습니다.
 

어떤 요소를 레이어로 승격 시킬지 선택해야합니다.
 문제는 생성하는 모든 레이어에 GPU 메모리와 관리가 필요하다는 것입니다.
 메모리가 제한된 장치에서는 성능에 미치는 영향이 계층 생성의 이점보다 훨씬 클 수 있습니다.
 MDN은 매우 신중한 방식으로 `변경 될 것`속성과 관련하여이 중 일부를 논의합니다.
 

최근 Web Animations API는 최근 모든 상록 브라우저에서 사용할 수있게되었습니다.
 MDN은 "브라우저가 해킹, 강제 또는`Window.requestAnimationFrame ()`없이 자체 내부 최적화를 수행 할 수 있도록합니다."라고 말합니다.
 

이는 요소를 레이어로 승격하는 데 관심이 없음을 의미하지만 그 사실을 명시 적으로 설명하지는 않습니다.
 의미가 제대로 알려지기 전에 API가 더 널리 사용되기까지 더 많은 시간이 걸릴 것입니다.
 

### 2. 페인트 최적화
 

`변환`및 `불투명도`를 제외한 모든 속성을 변경하면 항상 페인팅이 트리거됩니다.
 페인트는 종종 렌더링에서 가장 비용이 많이 드는 단계이므로 최적화에 적합한 영역입니다.
 

다음과 같은 몇 가지 작업을 수행 할 수 있습니다.
 

- 이동하거나 정기적으로 페인트되는 요소를 자체 레이어로 승격 : 이것은 첫 번째 휴리스틱에서 이어집니다.
 요소가 자체 레이어에있는 경우 인접한 요소의 페인팅을 트리거하지 않습니다.
 그러나이를 선택적으로 수행하고 성능에 미치는 영향을 감사하십시오.
 
- 페인트 영역 줄이기 : 요소가 많이 겹치지 않도록하여 페인트 영역을 줄일 수 있습니다.
 페이지의 특정 부분에 애니메이션을 적용하지 않는 방법을 찾을 수 있습니다.
 브라우저가 페인팅이 필요한 두 영역을 결합하고 전체 화면을 다시 칠할 수 있기 때문에 때때로 문제가됩니다.
 
- 페인트 복잡성 단순화 : 일부 속성을 그리는 데 더 많은 비용이 듭니다.
 예를 들어,`box-shadow`와 같은 블러와 관련된 것은`background-color`와 같은 속성보다 페인팅하는 데 더 비쌉니다.
 최종 결과를 얻기 위해 더 저렴한 스타일 세트 또는 대체 수단을 사용할 수 있는지 자문 해보십시오.
 

### 3. JavaScript 실행 최적화
 

자바 스크립트는 브라우저의 기본 스레드에서 실행됩니다.
 JavaScript가 오랫동안 실행되면 다른 렌더링 작업이 차단되어 잠재적으로 프레임이 삭제 될 수 있습니다.
 JavaScript가 실행되는시기와 실행 시간에 대해 전술적이어야합니다.
 

- `requestAnimationFrame` 또는 Web Animations API 사용 : 브라우저에 적합한시기에 시각적 변경을 수행하려고합니다.
 적절한 시간은 프레임의 시작입니다.
 프레임 시작시 JavaScript가 실행되도록 보장하는 유일한 방법은`requestAnimationFrame` 또는 Web Animations API를 사용하는 것입니다.
 애니메이션에 setTimeout 또는 setInterval을 사용하지 마십시오.
 기본적으로 프레임의 특정 지점에서 실행되고 버벅 거림이 발생할 수 있으므로 신뢰할 수 없습니다.
 JavaScript 라이브러리는 내부적으로 requestAnimationFrame을 사용합니다.
 
- 복잡성 감소 : 더 큰 작업을 마이크로 작업으로 나누는 배치 방식을 고려하십시오.
 각 작업이 몇 밀리 초 이상 걸리지 않도록하고 각 프레임의 `requestAnimationFrame`핸들러 내에서 실행합니다.
 웹 워커 사용을 고려할 수도 있습니다.
 

### 4. 비 UI 작업에 웹 작업자 사용
 

웹 작업자 (A.K.A. Dedicated Workers)는 자바 스크립트 버전의 스레드입니다.
 백그라운드에서 작업을 실행할 수있는 기회를 제공합니다.
 

메인 스레드는 포커스가되어야하는 UI 스레드로 생각할 수 있습니다.
 부드러운 애니메이션을 위해 애니메이션이 실행 중일 때 추가 작업을 수행 할 여유가 없습니다.
 애니메이션에 대한 데이터 처리가 필요한 경우 작업을 웹 작업자로 이동하는 것을 고려해야합니다.
 

좋은 사용 사례는 데이터 정렬, 검색 및 모델 생성과 같은 작업입니다.
 

```php
var dataSortWorker = new Worker("sort-worker.js");
dataSortWorker.postMesssage(dataToSort);

// The main thread is now free to continue working on other things...

dataSortWorker.addEventListener('message', function(evt) {
   var sortedData = evt.data;
   // Update data on screen...
});
```

큰 데이터 세트로 막대 차트를 정렬하는 애니메이션을 고려하십시오.
 데이터 정렬을 웹 작업자에게 푸시하면 막대 차트가 여전히 응답하는지 확인할 수 있습니다.
 

그런 다음 변경 사항을 점진적으로 애니메이션하도록 선택할 수 있습니다.
 이것은 사용자가 작업의 진행 상황을 알 수 있도록 적절한 피드백을 제공합니다.
 

Samsur는 물리학 계산을 웹 작업자에 넣는 최근 기사에서 WebXR 앱에서 웹 작업자를 사용하는 방법을 탐색했습니다.
 

웹 작업자로 할 수있는 작업에는 제한이 있습니다.
 DOM과 같은 일부 웹 API에 액세스 할 수 없습니다.
 따라서 특정 유형의 작업에만 적합합니다.
 

### 5. 입력 핸들러 디 바운스 또는 스로틀
 

애니메이션과 함께 입력 핸들러를 사용할 때는주의해야합니다.
 스크롤이있을 때 애니메이션이 트리거되거나 마우스 또는 터치 이벤트에 응답하는 경우 몇 가지 사항을 고려해야합니다.
 

스크롤과 같은 일부 입력 이벤트는 초당 100 개의 이벤트를 트리거 할 수 있습니다.
 스크롤 처리기가이 실행 속도에 대비하고 있습니까?
 

애니메이션을 그렇게 빨리 업데이트하고 싶지 않습니다. 확실합니다!
 디 바운싱 또는 스로틀 링을 통해이를 방지 할 수 있습니다.
 

디 바운싱은 갑작스런 이벤트를 하나로 묶기 때문에 이벤트에 그렇게 자주 응답하지 않습니다.
 

스로틀 링은 유사한 기술이지만 X 밀리 초마다 일정한 실행 빈도를 보장합니다.
 

때로는 리플 로우를 트리거하여 프레임을 삭제할 수 있습니다.
 우리는 리플 로우-페인트 루프를 발생시키는 액션을 피하고 싶습니다.
 Paul Lewis는 애니메이션에서 스크롤 이벤트 디 바운싱에 대해 말할 때이를 방지하는 방법에 대한 좋은 설명을 제공합니다.
 

### 6. 플립 기법 사용
 

FLIP 기술은 실행 전에 애니메이션을 사전 최적화합니다.
 아이디어는 애니메이션의 상태를 반전시키는 것입니다.
 일반적으로 우리는 매 프레임마다 비용이 많이 드는 계산을 수행하면서 "직선"애니메이션을 적용합니다.
 FLIP은 최종 상태를 기반으로 변경 사항을 미리 계산합니다.
 첫 번째 프레임은 최종 상태의 오프셋입니다.
 이렇게하면 애니메이션이 훨씬 저렴하게 재생됩니다.
 

이 기술은 사용자 입력에 의해 애니메이션이 트리거 될 때 특히 유용합니다.
 사용자 모르게 작업을 수행 할 수있는 기간이 100ms이기 때문에 비교적 비용이 많이 드는 사전 계산을 수행 할 수 있습니다.
 그 창 안에 있으면 사용자는 즉각적인 반응을 느낄 것입니다.
 

![image](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/flip-technique.png?resize=730%2C486&ssl=1)

애니메이션에 대한 다른 정신 모델이며 이해하기 위해 약간의 노력이 필요합니다.
 FLIP은 사건의 순서를 뒤집는 영화 테넷을 떠올리게합니다!
 

완전히 이해하려면 예제를 봐야합니다.
 David Khourshid는 FLIP 기술을 사용한 레이아웃 애니메이션에서이 주제를 자세히 다룹니다.
 

## 이러한 휴리스틱이 내 스타일을 꺾지 않을까요?
 

아니!
 제약을 느끼면 안됩니다!
 

`transform` 및`opacity` 속성으로 얼마나 많은 것을 달성 할 수 있는지 놀라실 것입니다.
 많은 창의적인 노력과 마찬가지로 일부 제약을 부과하면 실제로 프로세스를 단순화하고 더 창의적으로 만들 수 있습니다.
 이 코드 펜은이 두 가지 속성만으로 할 수있는 작업 중 일부를 보여줍니다.
 

<div class="cp_embed_wrapper"><iframe allowfullscreen="true" allowpaymentrequest="true" allowtransparency="true" class="cp_embed_iframe " frameborder="0" height="265" width="100%" name="cp_embed_1" scrolling="no" src="https://codepen.io/robjoeol/embed/mdrRpzB?height=265&amp;theme-id=light&amp;default-tab=html%2Cresult&amp;user=robjoeol&amp;slug-hash=mdrRpzB&amp;pen-title=Performant%20Animations%20Cheatsheet&amp;name=cp_embed_1" style="width: 100%; overflow:hidden; display:block;" title="Performant Animations Cheatsheet" loading="lazy" id="cp_embed_mdrRpzB"></iframe></div>

다른 속성도 자유롭게 사용하세요. 핵심 메시지는 다음과 같습니다. 먼저 속성에 도달하지 말고 현명하게 사용하세요!
 

## DevTools에서 측정하는 방법
 

Chrome DevTools에서 사용할 가장 유용한 컨텍스트에 대해 간략하게 설명하겠습니다.
 

성능을 감사하려면 성능 탭에서 필요한 모든 것을 찾을 수 있습니다.
 

![image](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/devtools-performance-tab.png?resize=730%2C874&ssl=1)

프레임 속도를 볼 때 60fps를 유지해야하는 것은 움직임이있을 때만 가능합니다.
 따라서 아무 일도 일어나지 않거나 거의 일어나지 않는 자연적인 골이 있습니다!
 

요약 탭의 방사형 원형 그래프는 렌더링 활동을 함께 그룹화합니다.
 그룹은 픽셀 파이프 라인의 단계에 해당합니다. 예를 들어 렌더링은 레이아웃과 스타일을 다룹니다.
 색상이 내 다이어그램과 일치합니다.
 우연이 아닙니다!
 😉
 

애니메이션 탭에서는 애니메이션을 검사하고 재생을 제어 할 수 있습니다.
 이 탭을 열려면 설정으로 이동해야합니다.
 

![image](https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/devtools-animations-tab.png?resize=466%2C310&ssl=1)

렌더링 탭은 렌더링 문제를 해결하는 데 중요합니다.
 이 탭을 열려면 설정으로 이동해야합니다.
 이를 통해 페인트, 레이어 및 스크롤 문제를 진단 할 수 있습니다.
 

![image](https://i0.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/devtools-rendering-tab.png?resize=569%2C373&ssl=1)

프레임 렌더링 통계를 활성화하여 프레임 속도 통계의 삽입 디스플레이를 표시 할 수 있습니다.
 애니메이션 작업을하는 동안 열면 도움이됩니다.
 

![image](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/devtools-frame-stats.png?resize=572%2C556&ssl=1)

자세한 내용은 Chrome DevTools 문서를 읽을 수 있습니다.
 Firefox의 Devtools도 훌륭합니다.
 

## 결론
 

애니메이션이 아름다워도 버벅 거림이 있으면 사용자에게 나쁜 취향을 남길 수 있습니다.
 성능이 뛰어난 애니메이션을 만드는 것이 크고 무서운 노력으로 느껴서는 안됩니다.
 브라우저에 16.7ms마다 수행하도록 요청하는 작업을 의도적으로 수행하면됩니다.
 이렇게하면 원활한 애니메이션을 만드는 데 성공할 수있는 최상의 샷을 브라우저에 제공합니다.
 애니메이션을 즐기십시오!
 