---
layout: post
title: "Rust용 패키지 인코딩 및 디코딩"
author: "Front Log"
thumbnail: "https://blog.logrocket.com/wp-content/uploads/2020/11/encoding-decoding-packages-rust.png"
tags: 
---


![image](https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2020/11/encoding-decoding-packages-rust.png?fit=730%2C487&ssl=1)

인코딩은 데이터를 한 양식에서 다른 형식으로 변환하는 프로세스입니다. 해독은 정확히 같은 것을 의미한다. 프로세스로 정의되는 경우가 많지만 인코딩은 특정 데이터 형식(문자 인코딩 또는 미디어 인코딩)도 참조합니다.

문자 인코딩/디코딩은 컴퓨터가 이진 데이터만 인식하기 때문에 프로그래밍에서 특히 중요하다. 이것은 일련의 문자(문자, 숫자, 기호, 문장 부호 등)를 특수 형식으로 변환하여 컴퓨터의 언어를 말하고 그것이 말하는 것을 이해하는 데 도움을 주는 방법입니다.

이 가이드에서는 Rust에서 데이터를 인코딩 및 디코딩하는 방법을 시연합니다.

## Rust의 인코딩 및 디코딩

인코딩과 디코딩이 드래그처럼 들린다고 생각한다면, 당신 혼자만이 아닙니다. 많은 에지 케이스가 있으며 프로세스가 상당히 복잡할 수 있습니다.

다행히도 다른 많은 프로그래밍 언어에서와 마찬가지로 Rust에서 인코딩과 디코딩은 이러한 대부분의 에지 사례에 대해 철저히 테스트된 모듈에 의해 처리된다. 효율적인 인코딩 및 디코딩 라이브러리는 특히 Rust와 같은 기계와 가까운 언어에 중요하다.

Rust의 인코딩은 비교적 간단합니다. 핵심 Rust 패키지는 아니지만 커뮤니티에서 개발한 몇 가지 솔루션이 작업을 상당히 잘 처리합니다. 이러한 도구를 사용하면 함수를 통해 인코딩 또는 디코딩할 문자 문자열을 보내고 추적된 결과(인코딩 또는 디코딩된 문자열)를 수신할 수 있습니다.

### base64 러스트 라이브러리

base64는 가능한 빠르고 정확하게 base64와 인코딩 및 디코딩하도록 설계되었습니다. 이름에서 알 수 있듯이, 이것은 base64에서만 작동합니다. 문자 그대로 인코딩과 인코딩 방식을 형상화하는 구성 기능과 함께 `엔코드()`와 `디코드()`라는 두 가지 변환 기능이 있다.

```cpp
extern crate base64;
use base64::{encode};
fn main() {
    let a = "hello world";
    println!("{}", encode(a)); // -> aGVsbG8gd29ybGQ=
}
```

믿거나 말거나, base64는 실제로 컴퓨터의 이진 파일을 처리할 때 가장 필요한 항목입니다. Base64는 전자 메일 첨부 파일부터 데이터베이스에 파일을 저장하는 데 이르기까지 웹에서 공유하는 모든 것에 사용되는 이진 데이터(이미지, 사운드 파일 등)를 인코딩하는 데 일반적으로 사용된다.

좀 더 깊이 잠수하려면 베이스 64 구루로 향하십시오.

### 녹이 슬다

`rust-encoding`은 대량의 문자 인코딩(WHATWG 표준에서 지원하는 모든 문자 인코딩)을 지원합니다. 매우 독특하게, 문자열을 처리하는 동안 수신된 오류를 지정된 값으로 대체하여 오류를 처리합니다. 오류가 감지되면 엄격한 모드를 사용하여 실행 =을 완전히 중지할 수 있습니다.

인코딩의 엔코드와 디코드 방식은 문자열을 벡(Vec<u8>)으로 변환하고 그 반대도 마찬가지이다. 많은 인코딩 유형을 지원하므로 라이브러리에서 다음 두 가지 방법으로 인코딩을 가져올 수 있습니다.

- 인코딩 프로세스에 사용할 인코딩을 첨부하는 `인코딩::all`입니다. 사용되지 않는 모든 인코딩 유형이 이진에서 삭제됩니다.
주어진 레이블을 기준으로 인코딩을 캡처한 후 정적 인코딩 유형을 반환하여 이진수가 더 커집니다.
- 인코딩 프로세스에 사용할 인코딩을 첨부하는 `인코딩::all`입니다. 사용되지 않는 모든 인코딩 유형이 이진에서 삭제됩니다.
- 주어진 레이블을 기준으로 인코딩을 캡처한 후 정적 인코딩 유형을 반환하여 이진수가 더 커집니다.

```undefined
use encoding::{Encoding, EncoderTrap};
use encoding::all::ISO_8859_1; // use with all
use encoding::label::encoding_from_whatwg_label; // use with label

assert_eq!(ISO_8859_1.encode("caf\u{e9}", EncoderTrap::Strict),
Ok(vec![99,97,102,233]));
let euckr = encoding_from_whatwg_label("euc-kr").unwrap();
assert_eq!(euckr.name(), "windows-949");
```

4년 동안 업데이트가 되지 않았음에도 불구하고 가장 많이 다운로드된 도서관(3.5k/week) 중 하나다. 그것은 매우 안정적이고 튼튼하다고 해도 과언이 아니다.

### 데이터 수집

data-protect는 15가지 인코딩 유형을 처리하며 사용자가 직접 사용자 지정 에지 케이스를 정의할 수 있도록 한다. 데이터 인코딩으로 문자를 인코딩하고 디코딩하는 방법은 매우 구체적이고 간단합니다(인코딩 및 디코딩하는 것은 매우 구체적이고 간단합니다.

```css
BASE64.encode(&input_to_encode)
HEXLOWER.decode(&input_to_decode)
```

라이브러리는 크기가 2에서 64 사이즈의 베이스에 대한 사용자 자신의 리틀 엔디안 ASCII 기본 변환 인코딩을 정의할 수 있는 관용도를 제공합니다. 이 코드는 특정 사용 사례이기 때문에 네이티브 인코딩 유형에서는 사용할 수 없습니다.

데이터 수집은 작고 현대적인 도서관이다. 매우 인기 있고 관리가 잘 되어 있어 지원되는 인코딩 유형을 사용해야 하는 경우 이 옵션을 선택하는 것이 좋습니다.

### ➡➡➡➡

우리는 정수를 문자로 간주하기 때문에 정수도 인코딩 및 디코딩해야 한다. `integer-encoding`은 두 가지 정수 유형인 `Fixed`를 지원합니다.Int와 VarInt. 또한 효율적인 읽기 및 쓰기 유형을 제공하여 정수 작업을 단순화합니다.

이 라이브러리는 구글의 프로토콜 버퍼로 작업하는 개발자들 사이에서 잘 알려진 특별한 사용 사례를 가지고 있는데, 이는 일반적이지 않은 유형으로부터 인코딩/디코딩할 필요성을 보여준다.

## 웹에 대한 Rust 인코딩 및 디코딩

인코딩 및 디코딩에 가장 실용적이고 일반적인 사용 사례 중 하나는 웹에서 문자열, 양식, 어레이, JSON 등을 사용하여 두 개의 서로 다른 엔티티(백엔드 및 프런트엔드)를 만든다. 매끄럽게 보일지 모르지만, 그것을 실현시키기 위해 많은 일들이 뒤에서 진행됩니다.

이 통신을 가능하게 하는 데 도움이 되는 몇 가지 라이브러리를 확대해보겠습니다.

### url 인코딩

사람들은 종종 왜 브라우저와 서버가 공간, 물음표 등과 같은 다른 이상한 문자와 함께 URL에서 매개 변수를 읽고 데이터를 형성할 수 있는지 궁금해한다. 비록 이것이 웹의 표준이지만, 모든 언어는 그것을 읽고 이해할 수 있어야 사용자의 브라우저와 통신할 수 있다.

러스트에서 url 인코딩은 아이언 웹 프레임워크에서 미들웨어 역할을 한다. Rust에서는 URL 쿼리 문자열을 읽기 쉬운 해시맵으로 구문 분석하는 것이 임무다. 키가 중복될 경우 정보가 손실되지 않도록 Vec에 값을 보관합니다. 따라서 쿼리 `a=b`는

`url encoded`는 MIME 유형의 포스트 본문인 `application/x-www-form-url encoded`도 구문 분석할 수 있습니다. 이것은 프런트 엔드의 양식을 작업할 때 유용합니다.

url 인코딩은 url 인코딩 및 디코딩에서 완전한 라이브러리이다. 4개 미만의 종속성을 가지고 작업하므로 안정적이고 생산에 착수할 준비가 된 것으로 간주됩니다.

### '멀터러즈'

멀티파트(multipart)와 멀티파트(multipart-async)에서 영감을 받은 멀터-rs는 러스트에서 멀티파트/폼 데이터(multipart/form-data) 콘텐츠 유형을 비동기식으로 구문 분석하는 능력으로 유명하다. 이전 라이브러리에서는 비동기 서버를 처리할 수 없었는데, 이는 Rust의 생태계가 비동기식으로 이동하기 때문에 매우 중요합니다.

multur-rs는 바이트의 스트림을 소스로 받아들여 파일의 데이터를 포함한 다중 부품/양식 데이터로부터 얻어진 모든 필수 필드를 포함하고 사용자 정의 파일에 기록할 수 있는 에니터블을 생성한다.

멀티파트 디코더의 필요성으로 인해 멀터러의 인기가 높아졌다. 이전의 인기 있는 것들은 부족했다. 비록 그것의 유지 관리자들이 여전히 새로운 쟁점들을 연구하고 있지만, 멀티터러들은 안정적이라고 여겨질 수 있다.

### %-contract

`백분율`은 URL 검색의 좋은 대안이다. 유사한 기능을 많이 공유하지만 다음과 같은 이유로 백분율 인코딩이 다릅니다.

- Iron 웹 프레임워크에 의존하지 않습니다.
URL 구조를 분할하여 쿼리 매개변수가 아닌 특정 부분만 가져올 수 있는 완전한 URL 구문 분석기입니다.
HTML 양식에 사용되는 `application/x-www-form-url 인코딩` 구문을 구문 분석 및 직렬화합니다.
- Iron 웹 프레임워크에 의존하지 않습니다.
- URL 구조를 분할하여 쿼리 매개변수가 아닌 특정 부분만 가져올 수 있는 완전한 URL 구문 분석기입니다.
- HTML 양식에 사용되는 `application/x-www-form-url 인코딩` 구문을 구문 분석 및 직렬화합니다.

```java
// code from url docs
use url::{Url, Host, Position};
let issuelisturl = Url::parse(
"https://github.com/rust-lang/rust/issues?labels=E-easy&state=open"
)?

;assert!(issue_list_url.scheme() == "https"); // takes the scheme
assert!(issue_list_url.hoststr() == Some("github.com")); //get the url's host
assert!(issue_list_url.port() == None); // get the port if there's one
assert!(issue_list_url.path() == "/rust-lang/rust/issues"); // the whole path
assert!(issue_list_url.query() == Some("labels=E-easy&state=open")); // get only the query
assert!(&issue_list_url[Position::BeforePath..] == "/rust-lang/rust/issues?labels=E-easy&state=open");
```

이 라이브러리는 상대 URL이 있는 것처럼 에지 케이스를 우아하게 처리합니다. URL에 가입하고 새 URL을 만들 수 있습니다.

```php
use url::Url;

let this_document = Url::parse("http://servo.github.io/rust-url/url/index.html")?;
let css_url = this_document.join("../main.css")?;
assert_eq!(css_url.as_str(), "http://servo.github.io/rust-url/main.css");
```

개발자 경험을 비교할 때, 특히 아이언 프레임워크에서 작업하지 않는 경우, `백분율 인코딩`이 `url-encoded`보다 우세하다. 게다가, 2015년도의 Rust를 여전히 사용하고 있지만, `퍼센트 인코딩`은 더 강력한 것으로 보인다.

### base64-url

base64-url은 현재 URL에 있는 또 다른 base64 인코더입니다. 불가능하게 들리지만, 이 기능은 URL을 줄이거나 이진 데이터를 포함해야 할 때 유용합니다.

### ➡-uuid

때로는 문자열의 길이를 줄이기 위해 간단히 인코딩하기도 합니다. blob-uuid는 인코딩 후 22로 변경되는 36자 UUID로 이를 지원합니다. 또한 URL에서 UUID를 공유하려는 경우 UUID를 숨길 수 있습니다.

```php
let uuid = Uuid::parse_str("557c8018-5e21-4b74-8bb0-9040e2e8ead1").unwrap();
assert_eq!("VXyAGF4hS3SLsJBA4ujq0Q", blob_uuid::to_blob(uuid));
```

## 놀이터

저는 Repl.it에 이러한 도서관들을 위한 놀이터를 준비했습니다. `Cargo.toml`을 사용하여 원하는 라이브러리를 추가하고 터미널에서 `Cargo run`을 누르십시오.

## 녹의 직렬화

직렬화란 데이터(레이, 객체 및 유사한 구조)를 하나의 문자열로 변환하여 저장 또는 전송이 용이하도록 하는 것을 의미한다. 직렬화는 매우 구체적인 주제이며 인코딩의 하위 집합으로 간주된다. 그러나 단순성을 위해 이 문서에는 직렬화 라이브러리가 포함되어 있지 않습니다.

러스트의 생태계는 serde_json, toml, 빈코드 등 우수한 직렬화 라이브러리를 제공한다. 이것들은 또한 뒤에서 인코딩과 디코딩의 형태를 겪는다.

## 결론

앞에서 설명한 것보다 Rust 인코딩 라이브러리가 더 많다. 우리는 가장 흔한 것들 중 몇 가지를 강조했습니다. 실제 시나리오에서는 작업해야 하는 형식에 따라 인코딩 라이브러리를 선택할 가능성이 높습니다.

인코딩 및 디코딩은 문자 인코딩에만 국한되지 않습니다. 러스트를 위한 다양한 미디어 인코딩 라이브러리도 있다.

위에 나열된 모든 라이브러리는 잘 구축되어 있고, 인기가 있으며, 생산용으로 안정적입니다. 이것은 단순히 인코딩과 디코딩이 현대 언어에서 필수적인 기능이기 때문이다. 목록이 다양해지고 각 라이브러리는 특정 사용 사례를 다르게 처리합니다. 그것은 그들을 서로 비교하는 것을 꽤 어렵게 만든다.

Rust는 인코딩 및 디코딩 라이브러리의 강력한 기반을 가지고 있다. 그러나 적어도 가장 인기 있는 인코딩 유형(UTF-8 및 base64)이 코어 Rust에 탑재되어 파이썬에서 사용할 수 있는 모듈만큼 확장 가능하도록 설계된다면 Rust가 더 성숙하게 느껴질 것이라고 생각한다.