---
layout: post
title: "WASM을 디버깅하고 안정적인 스택 추적을 달성하는 방법"
author: "Front Log"
thumbnail: "https://blog.logrocket.com/wp-content/uploads/2021/02/howtoddebugwasm.png"
tags: 
---


![image](https://i0.wp.com/blog.logrocket.com/wp-content/uploads/2021/02/howtoddebugwasm.png?fit=730%2C487&ssl=1)

웹 어셈블리(Web Assembly, 또는 WASM)는 개발자들이 Rust, C 또는 C+와 같은 언어에서 수집된 코드를 네이티브 속도에 가까운 속도로 사용할 수 있게 한다.

WASM은 빠른 샌드박스가 필요한 플랫폼의 경량 도커 교체로도 성공적으로 활용될 수 있다. 표준 WASI와 같이 플랫폼에 독립적인 인터페이스는 파일 시스템 액세스, 표준 입출력 등의 기본 기능 및 기타 유사한 기능을 가능하게 할 수 있다.

많은 이점에도 불구하고, 실제 버그가 재현하기 더 복잡해짐에 따라 WASM 디버깅은 어려울 수 있다. 소스 맵은 신뢰할 수 있는 스택 추적을 찾고, 실제로 어떻게 생겼는지 확인하며, WASM에서 신뢰할 수 있는 파일 이름을 얻는 데 사용할 수 있다.

이 기사에서는 WASM에 대해, 디버깅이 어려운 이유 및 소스 맵과 스택 언로딩이 관련된 WASM 디버깅 시 사용할 수 있는 몇 가지 해결 방법에 대해 설명합니다.

## 웹 어셈블리란?

WASM은 매우 컴팩트한 이진 포맷의 언어에 의존하는 현대의 웹 브라우저용 코드이며, 웹에서 작업할 수 있도록 컴파일 표적을 가진 다른 코딩 언어들을 제공한다. 자바스크립트와 함께 작동하며, 많은 기능을 공유한다. 이에 따라 WASM 코드를 쓸 줄 모르는 개발자들도 사용할 수 있게 됐다. 특히 WASM의 호환성은 웹 개발자의 75%가 코딩 요구의 대부분을 위해 자바스크립트를 사용한다고 보고하는 점을 고려할 때 매력적이다.

동일한 메모리 공간에서 모든 기능에 액세스할 수 있는 것은 아니므로 프로그램의 스택 활용도가 높아집니다. DWARF는 다른 프로그램을 디버깅하는 데 유용하지만 현재 실행 엔진에서 WASM과 완전히 기능하지는 않는다. 1년 전에, DWARF의 변화는 웹어셈블리에 대한 이해를 허용하기 위해 구현되었다. 이는 WASM용 LLVM 백엔드에 대한 주요 수정과 함께 제공됩니다.

궁극적으로, 개발자들, 특히 클라우드와 SaaS(Software-as-a-Service) 산업에서 일하는 개발자들에게 다양한 유형의 코드와 디버깅 방법을 마스터하는 것은 중요하다. 그 이유는 SaaS가 브라우저가 있는 모든 장치에서 데이터에 액세스할 수 있도록 허용하고 브라우저의 서버에 호스팅된 애플리케이션을 구성하는 코드를 사용하기 때문입니다. 서로 다른 브라우저에서 호환되며 버그가 없는 코드는 궁극적으로 고객 경험을 향상시키고 고객 보존을 증가시킵니다.

## 풀림 쌓기

먼저 스택 추적을 받으려고 합니다. 우리가 이걸 어떻게 해요? 그것은 스택을 푸는 것으로 시작한다. WebAssembly의 언와인딩 스키마가 활성화되어야 하는데, 보통 libunwind와 같은 라이브러리로 이루어진다. WASM용 언와인딩 스택의 경우 반환 주소에서 가장 중점을 두어야 할 사항이 있습니다. 그 이상의 것은 단순히 필요하지 않다.

레지스터를 캡처하여 스택을 풀 수 있으므로 실행 중인 프로그램에서 풀 수 있습니다. 이 방법은 Rust 오류 경고 또는 C++ 예외가 사용자에게 표시되는 경우에 가장 적합합니다. 스택 권선은 예외에 직면했을 때 소멸자를 실행할 수 있습니다.

스택을 해제하는 또 다른 방법은 메모리 덤프를 사용하는 것입니다. 레지스터가 있는 전체 스택 메모리는 메모리 덤프에 덤프된 다음 풀립니다. WebAssembly가 스택 언로딩을 촉진하는 데 가장 뛰어나지 않다는 것은 분명하지만, 브라우저가 대부분과 마찬가지로 JavaScript와 함께 작동한다면 큰 문제가 되지 않습니다.

WASM은 본질적으로 스택 머신이기 때문에 함수 호출은 자바스크립트의 자체 스택 추적 내에서 볼 수 있다. JavaScript에서 예외 개체를 생성하면 이 방법을 통해 해당 스택 추적을 분석할 수 있습니다.

## DWARF 디버깅 표준 및 WASM

DWARF 디버깅 표준은 바이너리의 단계적 디버깅에 오랫동안 사용되어 왔다. DWARF는 LLVM과 다른 컴파일러 백엔드에서 자주 사용되지만 이를 위해 설계되지는 않았다. DWARF가 현재 실행 엔진에서 WASM과 호환되지 않음에도 불구하고, 크롬과 파이어폭스는 여전히 디버깅 정보를 사용할 수 있다. 이들은 소스 맵을 WASM 실행에 연결하여 이를 달성한다.

이는 많은 사람들이 크롬이나 파이어폭스와 같은 브라우저에서 자바스크립트를 사용하는 것을 경계할 수 있기 때문에 보안을 확보하는 데 중요하다. 브리즈번 소재 소프트웨어 개발자 윌 엘리스(Will Ellis of Privacy Australia)에 따르면 크롬과 같은 특정 브라우저를 실행할 때 "일부 사람들은 자바스크립트를 완전히 끄고 진정으로 신뢰하는 웹사이트에서만 작동하도록 한다"고 한다. 다행히 원본 맵은 원본 입력 파일과 결과적인 자바스크립트 명령 사이에서 일종의 번역기처럼 매핑하는 형식을 정의할 수 있다. 이렇게 하면 원래 입력 파일의 보기에 대해 브라우저 디버깅을 수행할 수 있습니다.

DWARF 디버깅 표준은 실행 파일의 DWARF 데이터 내에 섹션을 내장한다. 이러한 임베딩은 WebAssembly가 확장 가능한 객체 형식이라는 사실에 의해 가능해진다. WASM은 WAST, 텍스트 기반 형식, 이진 형식의 두 가지 기본 형식으로 구성된다.

이 때문에 일부 WASM 도구는 무엇보다도 바이트 오프셋을 인식하지 못합니다. 불행히도 이 두 버전은 디버그 정보로 작업할 때 호환되지 않습니다.

WASM 파일에 디버그 정보를 포함시키는 데 몇 가지 심각한 문제가 있습니다. 이렇게 하면 누구나 잠재적으로 코딩의 압축을 풀고 메타데이터 또는 빌드 컴퓨터에서 파일 설명을 볼 수 있습니다. 또 다른 문제는 WASM에 대한 DWARF 데이터는 메인 WASM 파일보다 훨씬 큰 매우 큰 파일에만 저장할 수 있다는 것이다.

DWARF 분할은 여기서 DWARF 데이터가 주 실행 파일과 분리되는 해답이다. 일단 분할되면, 디버깅 데이터는 오직 디버깅을 위해 실행 불가능하고 비기능적인 파일에 저장될 수 있다.

어떻게 이런 것들을 다시 연결시킬 수 있을까요? 소스 맵과 같은 특수 섹션의 기본 WASM 파일에 디버깅을 위해 다운로드할 수 있는 파일에 대한 참조를 포함합니다.

디버그 데이터를 올바른 WASM 파일로 연결하는 것이 매우 중요합니다. 이 목적을 위해서는 디버그 ID가 필요합니다. WASM 툴체인은 이 파일들을 가져와서 디버그 데이터와 바이너리를 위한 기호 서버에 넣을 수 있다.

WASM에서도 소스 맵에 대한 과제가 난무하고 있다. 이는 정보 범위 지정, 함수 이름 액세스 또는 매핑, 디버깅 모드에서 변수 찾기가 어렵고, 텍스트 기반 버전의 WASM에서만 사용할 수 있기 때문이다.

디버깅할 때 웹 어셈블리가 JavaScript 및 기타 WASM 모듈과 상호 작용하는 방식을 고려하는 것이 중요하다는 점을 명심하십시오. WASM의 스택 추적은 위치 정보를 인코딩하는 파일 이름과 함께 제공되지만, 두 개의 다른 모듈이 동일한 함수 인덱스를 가질 수 있기 때문에 함수 인덱스를 찾기는 여전히 어렵다. WASM 모듈은 격리된 컨테이너에 보관되지만 기능을 내보내고 가져올 수 있습니다.

## 결론

웹 어셈블리는 디버깅과 관련된 어려움에도 불구하고 개발자를 위한 훌륭한 도구입니다. 몇 가지 단계가 더 있고 스택 기반 설계를 이용하기 위해 약간의 창의성이 요구되지만, WASM을 성공적으로 디버깅하기 위해 DWARF를 사용하는 것은 여전히 가능하다.