---
layout: post
title: "편백 대 편백 셀레늄: 사이프러스가 더 나은 옵션인 이유"
author: 'Code Tower'
thumbnail: https://blog.logrocket.com/wp-content/uploads/2019/07/cypressio.png
tags: undefined
---


![image](https://i0.wp.com/blog.logrocket.com/wp-content/uploads/2019/07/cypressio.png?fit=730%2C412&ssl=1)

## 셀레늄의 문제

편집자 참고: 본 게시물은 Cypress 6.1.0과 함께 도입된 변경사항과 개선사항을 반영하여 2021년 1월 19일에 업데이트되었습니다.

시작하기 전에 이 게시물은 특정 프로젝트나 함께 작업한 자동화 테스터에 대한 것이 아니라는 점을 강조하고 싶습니다. 저는 최근 세 가지 프로젝트에서 이러한 행동을 보았습니다. 그리고 제가 함께 작업한 거의 모든 자동화 테스터는 이 고장난 기계를 작동시키기 위해 배짱을 부러뜨렸습니다.

저는 성공을 보장하기 위해 백만 번의 자동화 테스트가 필요하다는 것을 최근에 작업한 모든 계약에 메모가 첨부되었다고 확신합니다. 우리는 이 테스트의 가치에 대해 의문을 제기하기 위해 멈춰서는 안 된다. 우리는 우리 아이들처럼 그들을 보호해야 합니다.

이 시험들은 셀레니움어로 쓰여져야 하는데, 제가 나중에 언급할 내재적인 알려진 문제들 때문에 거의 모든 사람들이 꽤 암울한 경험을 하고 있음에도 불구하고 말이다. 그들의 문서에 따르면, Selenium은 웹 브라우저의 자동화를 지원하는 다양한 도구와 라이브러리를 제공하며 브라우저 할당의 확장을 위한 배포 서버뿐만 아니라 브라우저와의 사용자 상호작용을 에뮬레이트하는 확장을 제공한다. 또한 W3C WebDriver 사양을 구현하기 위한 인프라를 갖추고 있어 모든 주요 웹 브라우저에 대해 상호 호환 가능한 코드를 작성할 수 있습니다.

셀레늄 테스트는 쓰기에 미친듯이 어렵지만, 그렇다고 해서 우리를 망설이게 하지는 않을 것이다. 대신, 우리는 프로그래밍에 늦게 들어왔거나 개발 초년생인 테스터들을 데려올 것이다. 우리는 경험이 부족한 개발자들에게 이런 어려운 시험들을 쓰게 할 것입니다.

셀레늄 테스트는 쓰기 어려울 수 있지만 복사하여 붙여넣기가 간단합니다. 물론, 이것은 모든 종류의 문제로 이어집니다.

우리는 종종 "만약 그것이 움직인다면, 그것에 대한 셀레늄 시험을 써라"라는 말을 듣는다. API, 프런트 엔드, 백엔드, 미들엔드, 해피 경로, 슬픈 경로, 거꾸로 된 경로 등에 대해 자동화 테스트를 작성해야 합니다.

수동 테스트를 할 시간이 없을 텐데, 어떻게 그럴 수 있을까요? 우리는 쓰고 유지해야 할 이 모든 날염 셀레늄 테스트들을 가지고 있다. 우리는 이미 이 단거리 경주에 늦었고, 모든 이야기는 자동화 테스트를 거쳐야 한다.

1년 정도 그리고 미친 듯이 긴 체격 후에, 우리는 이것이 약간 어리석었다고 판단하고 그것들을 모두 삭제할 것이다. 더 나쁜 것은 다시 시작하세요.

### 왜 아직도 셀레늄을 쓰는 거죠?

위의 질문에 답할 수 있다면 우리 존재의 실체를 더 잘 이해할 수 있을 것 같습니다. 농담은 제쳐두고, 셀레늄의 사용이 왜 그렇게 널리 퍼졌을까요? 당황스럽긴 하지만 몇 가지 제안이 있습니다.

- 그것은 산업 표준이고, 많은 온라인 자원과 기댈 수 있는 거대한 공동체이다.
- 여러 OS에서 작동하며 여러 언어를 사용할 경우 선택한 언어와 플랫폼에 대한 지원 범위가 넓어집니다.
- 크로스 브라우저 테스트. Selenium은 모든 주요 브라우저를 지원하므로 Chrome, Firefox, Safari, IE, Edge 등에서 테스트할 수 있습니다.

공평하게 말하면, 백만 건의 합격 시험 작성이 갑자기 급증한 것은 셀레늄의 잘못이 아니다. 제가 아는 바로는 올바른 자동화 테스트 횟수는 슬픈 경로나 거꾸로 된 경로가 아닌 하나의 행복한 경로 테스트입니다. 이 한 가지 테스트는 당사의 시스템이 업무용으로 개방되어 있는지 확인하기 위한 연기 테스트입니다.

단위 테스트와 통합 테스트는 실행, 구현 및 유지 관리 비용이 저렴하며 테스트의 대부분이 되어야 합니다. 모두들 시험 피라미드에 대해 잊어버렸나요?

## 셀레늄이 당신에게 효과가 없는 이유

셀레늄의 문제는 타이밍이라는 한 단어로 표현할 수 있다.

테스트가 올바르다고 주장하기 위해 코드 작성을 시작하기 전에, 우리는 우리가 상호작용해야 할 모든 요소가 가시화되고 시뮬레이션된 입력을 받아들일 수 있는 상태에 있는지 확인해야 한다. 원격 API 호출은 해결되어야 하고, 애니메이션과 스피너는 종료되어야 합니다. 현재 대부분의 앱을 구성하는 동적 콘텐츠는 현재 검색된 API 호출 데이터에서 렌더링을 완료해야 합니다.

그러면 우리는 이 엄청난 비동기성이 일어나는 동안 무엇을 할 수 있을까요? API 호출이 완료되거나 아름다운 SVG 스피너 오버레이가 우리의 가상 세계에 어둠의 베일을 씌울 때까지 특정 텍스트 입력이 비활성화되기 때문에 어떻게 테스트가 완료되거나 종료되는 것을 막을 수 있을까요?

일반인의 관점에서, 우리는 HTML 요소가 준비 상태가 될 때까지 기다린다. Selenium speak에서는 많은 사용자 정의 `wait forXXXXXX` 코드 도우미를 작성합니다.

기다려라보름달과 늑대인간은 식사를 마치거나 좀 더 현실적으로…

```coffeescript
wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath("//input[@id='text3']")));
```

가장 나쁜 범죄 중 하나는 `나사`를 사용하는 것이다."수면" "이것은 희박한 공기에서 임의의 숫자를 뽑아내어 UI가 준비되었다고 생각할 때 엉뚱한 추측으로 사용되는 극악무도한 범죄이다. 제발 이러지 마

다음은 CI 빌드 보고서를 검토하는 동안 발견한 셀레늄 예외 사항입니다.

- `No Such Element`예외` – 계속 진행하십시오. 여기서 입력 내용을 찾을 수 없습니다.
- `ElementNotVisible`예외` – 이 건방진 스캠은 감질나게 가깝지만 충분히 가깝지는 않다는 것을 의미하며, DOM에는 있지만, 이 스캠으로 한 가지도 할 수 없습니다.
- `Stale Element Reference Exception` – 이 요소는 하루 동안 작업을 마치고 펍에 갔다. 내일 다시 시도하십시오.
- 시간 초과예외 – 시간이 끝날 때까지 기다릴 수 있으며 하려는 일은 일어나지 않을 것입니다. 넌 방금 7점 만점에 성공했어.

## 보라: 그 낙타리

제가 경험한 가장 충격적인 순간 중 하나는 자동화 테스트 실패에 따른 빌드 실패입니다. 단지 빌드를 다시 실행하기만 하면 마법처럼 통과할 수 있습니다. 이러한 현상이나 좀비 자동화 테스트는 종종 플라크라고 불린다.

플레이크의 주요 문제는 비결정적이라는 점인데, 이는 서로 다른 시간에 동일한 입력으로 실행할 때 테스트가 다른 동작을 나타낼 수 있다는 것을 의미한다. 비결정론적 검정의 수가 증가함에 따라 회귀 검정군의 신뢰도가 상승하는 것을 볼 수 있습니다.

플레이키 테스트는 우리가 `나사`로 길들이려고 하는 타이밍, 지연 시간 및 비동기성의 매카브 연산자까지 내려갈 가능성이 높다.잠을 자다.정신차리려고 계속 글을 써야 하는 영웅 도우미.

만약 우리가 이 모든 비동기식 프로그래밍을 없앨 수 있다면 그리고 우리의 세계가 선형적으로 또는 동시에 움직이기 시작한다면 얼마나 더 쉬울지 생각해보세요. 시험해 볼 수 있는 세상이란 얼마나 자연스러운가.

Cypress.io은 이를 위해 나선다.

## Cypress.io: 셀레늄의 대체품

### 사이프러스란 무엇인가?

사이프레스(Cypress)는 엔드 투 엔드 테스트를 위한 자바스크립트 기반 프레임워크이다. Mocha를 기반으로 하며 브라우저에서 실행되므로 비동기 테스트가 가능합니다. Cypress 문서에 따르면, Cypress는 엔드 투 엔드 테스트 외에도 통합 테스트 및 단위 테스트를 작성하는 데 도움을 줄 수 있습니다.

사이프러스는 다음 기능을 포함합니다.

- 시간 여행: 테스트를 실행할 때 사이프러스가 스냅샷을 생성합니다.
- 디버깅: 읽기 쉬운 오류와 스택 추적을 통해 디버깅이 쉬워집니다.
- 자동 대기: 다음 단계로 넘어가기 전에 자동으로 명령 및 주장 대기
- 스파이, 스텁 및 시계: 기능, 서버 응답 또는 타이머의 동작 확인 및 제어
- 네트워크 트래픽 제어: 서버를 사용하지 않고 에지 케이스 제어, 스텁 및 테스트
- 스크린샷 및 비디오: 실패 시 자동으로 촬영된 스크린샷 또는 CLI에서 실행할 때 전체 테스트 제품군의 비디오 보기
- 크로스 브라우저 테스트: Firefox 및 Chrome-family 브라우저(Edge 및 Electron 포함) 내에서 로컬로 테스트 실행

### 사이프러스와 셀레늄의 차이점

Cypress.io과 Selenium의 주요 차이점 중 하나는 Selenium이 테스트 중인 브라우저나 장치 외부의 프로세스에서 실행된다는 것이다. Cypress는 브라우저와 테스트 대상 장치와 동일한 실행 루프에서 실행됩니다.

사이프러스는 브라우저 내에서 대부분의 명령을 실행하므로 네트워크 지연이 없습니다. 명령어는 렌더링 가능한 한 빨리 응용프로그램을 실행하고 구동합니다. 복잡한 UI를 가진 최신 JavaScript 프레임워크를 처리하기 위해 주장을 사용하여 응용 프로그램의 원하는 상태를 Cypress에 알려줍니다.

사이프러스는 다음 단계로 넘어가기 전에 프로그램이 이 상태에 도달할 때까지 자동으로 기다립니다. 수동 대기 또는 재시도로 인한 소란으로부터 완전히 격리됩니다. 사이프러스는 자동으로 요소가 존재하기를 기다리며 DOM에서 분리된 오래된 요소를 생성하지 않습니다.

이것이 주요 이점입니다. 사이프러스는 장치와 동일한 실행 루프에서 실행함으로써 셀레늄의 주요 문제를 제거했다. 사이프러스는 DOM 요소가 나타날 때까지 기다립니다.

반복한다: 사이프러스는 이 모든 대기중인 일을 처리한다. `나사`가 없습니다.잠, 기다리지 말고문 대통령의 조력자. 이게 무슨 뜻인지 모르겠어요?

이게 얼마나 좋은지 제대로 파악하려면 고통을 겪어야 합니다.

다음은 사이프레스 테스트의 몇 가지 예입니다.

이들의 부재의 동의어 중 하나는 시기나 음란한 `기다림` 도우미들이다.

```coffeescript
context("Login", () => {
  beforeEach(() => {
    cy.visit("localhost:8080/login");
  });

  it("can find and type in email", () => {
    cy.get("#email")
      .type("fake@email.com")
      .should("have.value", "fake@email.com");
  });

  it("can find and type in password", () => {
    cy.get("#password")
      .type("fakepassword")
      .should("have.value", "fakepassword");
  });

  it("will fail when type invalid user credentials", () => {
    cy.get("#email").type("fake@email.com");

    cy.get("#password").type("fakepassword");

    cy.get("input[type=submit]").click();

    cy.get("#login-message").should("have.text", "Login failed");
  });
});
```

나는 이 시험이 좋다. 이들은 용도를 명확히 밝히고 플랫폼의 한계를 보완하는 코드로 난독화하지 않는다.

다음은 Cypress를 통해 축 접근성 도구를 실행하기 위해 작성한 몇 가지 테스트입니다.

```coffeescript
import { AxeConfig } from "../support/axeConfig";

describe("Axe violations", () => {
  beforeEach(() => {
    cy.visit("/");
    cy.injectAxe();
  });

  it("home page should have no axe violations", () => {
    cy.configureAxe(AxeConfig);
    cy.checkA11yAndReportViolations();
  });
});
```

여기에 웹드라이버를 사용한 유사한 테스트가 있습니다.

```coffeescript
// in e2e/home.test.js
import assert from 'assert';
import { By, until } from 'selenium-webdriver';
import {
    getDriver,
    analyzeAccessibility,
} from './helpers';

describe('Home page', () => {
    let driver;

    before(() => {
        driver = getDriver();
    });

    it('has no accessibility issues', async () => {
        await driver.get(`http://localhost:3000`);

        // The dreaded wait until.  Abandon hope
        await driver.wait(until.elementLocated(By.css('h1')));

        const results = await analyzeAccessibility();
        assert.equal(results.violations.length, 0);
    });
});
```

가장 두드러진 차이와 걱정스러운 것은 지연 시간이다. 두 번의 기다림 전화와 두려운 기다림 전화(Element Located.Located) 전화가 있다. 간단한 테스트지만 상호 작용이 많을수록 더 많은 `기다리기` 도우미가 필요하게 되고, 그 후유증이 확산되기 시작한다.

여기 여러분이 더 배우고 싶다면 사이프러스에서 엔드 투 엔드 테스트들을 쓰는 튜토리얼이 있습니다.

### JavaScript를 끝까지 사용

사이프러스는 분명히 프런트 엔드 개발자를 겨냥하고 있다. 사이프러스 설치는 간단하며 npm 또는 yarn 중 원하는 패키지 관리자를 통해 수행됩니다.

```undefined
npm install cypress --save-dev
```

그것은 정말로 더 쉬울 수 없다. Chrome Web Driver와 Selenium 세계의 친구 다운로드와 비교해 보십시오.

셀레늄과 같은 다국어 지원은 없다. JavaScript 또는 TypeScript만 있으면 원하는 프로그래밍 언어를 사용할 수 있습니다.

### 사이프러스 콘스

물론, 단점도 있고, 그 중 일부는 눈에 띄기 때문에 이런 것들을 나열하지 않는 것이 아쉬울 것 같습니다.

- 사이프러스는 비교적 새롭습니다. 그리고 셀레늄이 하는 거대한 공동체를 가지고 있지 않습니다.
- 앞에서 말한 것처럼 자바스크립트나 버스트입니다. C# 및 Java의 오래된 정적 언어로 Cypress 테스트를 작성하지 않습니다.
- 브라우저 내에서 실행되므로 여러 탭을 지원할 수 없습니다.

또한 사이프러스는 기본 모바일 앱을 지원하지 않습니다. 그러나 Cypress를 사용하여 모바일 웹 브라우저의 일부 기능을 테스트하고 Ionic과 같은 프레임워크를 사용하여 브라우저에서 개발된 모바일 애플리케이션을 테스트할 수 있습니다.

## 사이프러스가 셀레늄을 대체할 것인가?

내가 승낙하고 싶은 만큼, 나는 의심이 간다. 셀레늄 외에 다른 세계를 전혀 알지 못한 자동화 테스터들이 있는데, 머지않아 멀어지는 것은 어려울지도 모른다.

## 결론

이 기사를 시작할 때 언급했듯이, 자동화 테스트에 대한 저의 경험은 좋지 않습니다. 많은 돈, 시간, 그리고 고통은 만족스럽지 못한 급여를 받기 위해 유지되기 어려운 수천 개의 테스트를 유지하는 데 사용됩니다. 자동화 테스트는 제 경험상 긴 CI 구축 기간을 보장했을 뿐입니다.

우리는 개발자로서 자동화 테스트를 더 잘해야 합니다. 우리는 더 많은 일을 하고 유용한 테스트를 덜 쓸 필요가 있다. 우리는 가장 어려운 코드 중 일부를 경험이 부족한 개발자들에게 남겼습니다. 제 돈으로는 이곳이 여전히 진짜 벌레가 발견되는 곳이라면 수동 테스트는 구식인 것처럼 보이게 만들었습니다.

우리는 자동화 테스트가 무엇을 달성할 수 있는지에 대해 분별력이 있어야 합니다.

사이프러스는 사물을 동기적으로 만들기 때문에 좋다. 이것은 모든 고통의 세계를 없애주고, 이것을 위해, 나는 확고히 승선하고 있다. 그러나 이것은 수천 개의 사이프레스 테스트들을 쓸 수 있는 청신호가 아니다. 테스트의 대부분은 몇 가지 행복한 경로 자동화 테스트에 들어가기 전에 통합 테스트 계층을 사용한 단위 테스트입니다.

물론 이것은 일어나기엔 너무 합리적인 전략이다.