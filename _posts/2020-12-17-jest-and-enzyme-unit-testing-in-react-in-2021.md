---
layout: post
title: "농담과 효소: 2021년 반응에서의 유닛 테스트"
author: 'Code Tower'
thumbnail: https://blog.logrocket.com/wp-content/uploads/2020/12/jest-react-enzyme-unit-testing.png
tags: undefined
---


![image](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2020/12/jest-react-enzyme-unit-testing.png?fit=730%2C487&ssl=1)

2021년 React의 유닛 테스트는 프레임워크 초기부터 많은 성과를 거두고 있습니다. 제스트와 효소 같은 도구들은 생산에 들어가는 코딩 오류를 40-80%까지 줄여준다. 이러한 광범위한 프레임워크를 구축할 때 더 이상 자체 솔루션을 구축할 필요가 없습니다.

이 기사에서는 제스트와 효소를 사용하여 리액션에 대한 단위 테스트를 작성하는 방법과 구성 요소 트리와 기능을 안정적으로 테스트하는 방법에 대해 알아보겠습니다.

## 전제조건

이 튜토리얼에는 React에 대한 기본 지식이 필요합니다. Node.js를 사용하여 콘텐츠를 제공합니다.

제스트와 효소와 함께 작업하려면 여러 라이브러리를 설치해야 합니다. Node.js` 패키지에 다음 섹션을 포함합니다.json 파일 또는 `npm`을 사용하여 패키지 설치:

```undefined
"devDependencies": {

"@babel/preset-env": "7.12.7",

"@babel/preset-react": "^7.12.7",

"babel-jest": "^26.6.3",

"jest": "^26.6.3",

"react-test-renderer": "^17.0.1"

}
```

React는 프런트 엔드 프레임워크이지만 Node.js를 사용하여 테스트를 실행하는 데 초점을 맞출 것입니다. npm 명령을 사용하여 테스트를 실행합니다.

## 샘플 반응 프로그램

유닛 테스트에 뛰어들기 전에 간단한 프로그램을 만들어야 합니다. 간단한 계산의 결과를 반환하는 함수와 콘텐츠를 렌더링하는 함수를 만든다.

다음을 `index.js` 또는 사용자 지정 JavaScript 파일에 추가하십시오.

```js
function getComputation(a, b){
return a + b;

}
function sayHello(){
return <div><p>Hello World!</p></div>;

}
```

웹 서버를 시작하고 응용 프로그램의 인덱스 페이지를 엽니다. 페이지에 "Hello World!" 텍스트가 표시되는지 확인합니다.

## 반응의 단위 테스트는 무엇입니까?

`say hello` 기능이 올바른 콘텐츠 반환을 중지했거나 완전히 실패했다고 가정합니다. 프로덕션으로 이동하기 전에 메서드가 작동을 중지했음을 알고 싶을 것입니다.

단위 테스트를 통해 코드가 생산 초기에 예상대로 작동하는지 확인할 수 있습니다. 개발자는 각 기능이 정상적으로 작동하도록 기능을 작성할 때 이러한 기능을 통합합니다. 테스트는 강력한 로깅과 결합하면 매우 효과적입니다.

## 양호한 단위 테스트 작성

테스트는 철저해야 하므로 시간과 노력이 필요합니다. 그러나 광범위한 제품군을 작성하면 애플리케이션이 예기치 않게 장애를 일으키지 않고 프로세스에서 사용자를 몰아낼 수 있으므로 안심할 수 있습니다.

양호한 단위 테스트:

- 개별 기능 테스트
- 예상 동작 및 기능에 대한 쓰기 테스트
- 다양한 자산 및 행동에 공통 언어 사용
- 로그 및 기타 정보를 통해 문제에 대한 통찰력 제공

시험이 시간이 지남에 따라 제2의 특성이 되듯이 광범위한 시험을 작성하는 것도 시간이 지남에 따라 쉬워진다.

## 코딩 모범 사례가 테스트에 미치는 영향

테스트 기능과 코드 품질을 모두 향상시키기 위해 따라야 할 몇 가지 모범 사례가 있습니다. 코딩 표준과 모범 사례는 응용프로그램이 원활하게 작동하도록 유지하는 것과 함께 제공됩니다.

테스트 실행 및 애플리케이션 작업 용이성 향상:

- 반복 코드를 개별 및 테스트 가능한 기능으로 분할
- 기능 결합을 피하십시오.
- 중요 코드를 묻지 않음

읽기 어려운 어수선한 코드, 많은 기능 부분을 단일 기능으로 감싸는 것은 시험을 더 어렵게 만든다. 나쁜 관행은 또한 미래의 발전을 더 어렵게 만든다.

## 제스트 및 효소의 단위 시험

제스트와 효소는 처음부터 틀을 만들지 않고 강력한 단위 테스트를 쓸 수 있게 해줍니다. 이러한 도구는 개별 기능을 작성하는 것보다 더 자연스러운 방식으로 테스트를 마무리하고 보고 및 주장에 액세스할 수 있습니다.

`src` 폴더 아래의 위치에 `index.test.js`를 생성하십시오. 이 파일에서 `getComputation` 기능에 대한 테스트를 작성합니다.

```coffeescript
const idx = require('./index.js')
describe("testComputation", () =>{
it('adds 1 + 5', () =>{


    expect(idx.getComputation(1, 5)).toBe(6);


});

});
```

프로그램이 올바른 결과를 반환하도록 보장합니다. 당신은 여전히 시험 주자에게 당신의 시험에 대해 말할 필요가 있다.

다음 구성을 `testconfig.json`이라는 새 파일에 씁니다.

```undefined
{

"verbose": true,

"testURL": "http://localhost/",

"testMatch": ["**index.test.js?(x)"]

}
```

testMatch` 배열을 `test.index.js` 경로로 변경합니다. Jest에게 정규식을 사용하여 모든 파일의 테스트를 읽으라고 말할 수 있습니다.

마지막으로 `패키지`에 다음을 추가합니다.json은 노드에게 장치 테스트 실행 방법을 알려 줍니다.

```bash
"scripts": {

"test": "jest",

}
```

명령줄에서 테스트 실행:

```undefined
jest testComputation –config=./testconfig.json
```

Jest는 test.index.js 파일에서 testcomputation 테스트를 실행할 것이다. 각 테스트의 세부 정보가 콘솔에 나타납니다.

## DOM 테스트

Return은 DOM 렌더러를 제공합니다. 효소는 각각의 성분을 시험할 수 있도록 하기 위해 이것을 기반으로 한다. 개별 구성 요소를 확인할 수 있습니다.

say hello 함수는 div를 반환합니다. 다음 테스트를 만들어 페이지가 올바르게 렌더링되는지 확인할 수 있습니다.

```coffeescript
import {shallow} from 'enzyme';
describe("testRender", () =>{
it("should render hello world", () => {


    const html = idx.sayHello();


    const wrapper = shallow(html).toJSON();


    expect(wrapper.text()).toContain("Hello World!");


});

});
```

나무를 바꾸지 않으면 사단이 똑같아 보일 거예요. 이렇게 하면 결과 내용이 일관성이 유지됩니다. 원치 않는 변경을 탐지하면 사용자 환경을 개선하는 데 도움이 됩니다.

## 효소는 무엇을 하는가?

위의 테스트 사례에서 효소는 반응.js 성분 트리를 장착하고 통과시키는 메커니즘을 제공합니다. 이 프레임워크를 통해 쉽게 구성 요소를 주장, 조작 및 이동할 수 있습니다.

렌더러에 접근할 수 없었던 과거와 달리, 제스트는 내용을 렌더링할 수 있는 반면 효소는 내용에 대한 가정을 테스트할 수 있습니다. 이렇게 하면 위에서 설명한 바와 같이 문자열과 일치해야 하는 버기 사용 사례를 작성할 수 있습니다.

## 효소를 이용한 로깅

효소는 또한 당신의 유닛 테스트의 창 역할을 할 수 있다. 특히 로그가 제대로 제공되지 않는 종속성을 사용하는 경우 이유 없이 테스트를 실패하는 것만큼 좌절스러운 일은 없습니다.

개체를 포장하여 콘솔에 인쇄할 수 있습니다.

```cpp
const html = idx.sayHello();

const wrapper = shallow(html).toJSON();

console.log(wrapper.debug());
```

연속형 통합 프레임워크 내에서 테스트를 실행하는 경우 이 정보를 중앙 위치에 기록합니다. 선택한 도구는 이미 콘솔에서 정보를 집계할 수 있지만, 로그 저장소 또는 다른 검색 가능한 로그 저장소 플랫폼을 사용하여 이러한 로그를 항상 Elastic 검색에 저장할 수 있습니다.

## 연속 적분에서의 단위 시험

단위 테스트는 애플리케이션 상태를 보장하기 위한 광범위한 전략의 일부입니다. 이는 시스템의 버그 수를 줄이기 위한 첫 번째 단계입니다.

이러한 툴을 연속 통합 툴에 사용하면 업데이트 후 애플리케이션이 중단되지 않도록 방지할 수 있습니다. 지속적인 통합은 빌드를 자동화하므로 예기치 않게 문제가 발생할 수 있습니다.

Circle CI 및 Gitlab CI와 같은 도구를 사용하여 빌드 프로세스의 일부로 도커 컨테이너에서 테스트를 실행할 수 있습니다. 테스트에 실패하면 전체 빌드가 실패합니다. 빌드의 문제를 추적하려면 Application Performance Management 또는 다른 로깅 도구에 로그온해야 합니다.

## 코드 적용 범위

응용 프로그램이 커질수록 철저한 테스트가 더욱 어려워집니다. 코드 적용 범위(테스트를 통해 실행되는 소스 코드의 양)는 추적하는 데 유용한 통계량입니다. 코드 적용 범위 도구를 사용하여 프로젝트의 테스트되지 않은 부분을 찾습니다.

Jest를 사용하면 테스트를 실행할 때 이 통계를 추적할 수 있습니다. 콘솔의 `-커버` 옵션을 사용하여 Jest GitHub 코드 커버리지 배지에서 100% 작업할 준비를 하면 됩니다. 결과 보고서는 도달한 문장, 분기, 함수 및 선을 표시합니다.

## 2021년 반응에서의 유닛 테스트

단위 테스트는 개발의 중요한 부분입니다. 오류를 줄이고 생산성을 높이며, 그렇지 않으면 디버깅 코드에 소요되는 시간을 없앱니다.

Jest는 2021년 React에서 철저한 유닛 테스트를 수행할 수 있는 강력한 플랫폼입니다. 선택한 연속형 통합 도구에 테스트를 배포하고 로그를 액세스하여 애플리케이션의 상태를 유지하십시오.