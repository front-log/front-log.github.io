---
layout: post
title: "JavaScript에서 GraphQL 서버 코딩 대 워드프레스"
author: 'Code Tower'
thumbnail: https://blog.logrocket.com/wp-content/uploads/2020/12/graphql-server-javascript-wordpress.png
tags: undefined
---


![image](https://i0.wp.com/blog.logrocket.com/wp-content/uploads/2020/12/graphql-server-javascript-wordpress.png?fit=730%2C487&ssl=1)

그래프QL은 특정 언어의 구현이 아니라 규격이다. 이와 같이, 자바스크립트, PHP, Rust, 파이썬, Go 등을 포함한 많은 언어를 위한 GraphQL 서버가 있다.

첫 번째 GraphQL 서버인 graphql-js는 JavaScript로 코딩되어 있다. GraphQL 규격의 참조 구현이기도 하므로 다른 GraphQL 서버는 자체 솔루션에 대해 `graphql-js`에 의해 설정된 아키텍처 결정을 따를 수 있다.

그러나 언어마다 특성이 다르며, 자바스크립트 기반 서버에 대한 솔루션을 포팅하는 것은 다른 언어를 기반으로 하거나 응용 프로그램의 작동 방식에 대한 다른 철학을 사용하여 최적의 결과를 산출하지 못할 수 있다. 대신, 이러한 지침에서 벗어날 공간을 확보하면 더 나은 결과를 얻을 수 있다.

이 기록을 위해 WordPress용 GraphQL 솔루션 구축이 다음 세 가지 상황에서 표준 JavaScript 지침과 어떻게 다른지 알아보겠습니다.

- 쿼리 해상도 확장
- 스키마의 이름 간격 지정(또는 지정 안 함
- 내포된 돌연변이 사용(또는 사용 안 함)

WordPress용 나만의 플러그인 GraphQL API를 사용하여 WordPress 접근 방식을 시연할 것이다.

비교를 위해, 나는 자바스크립트와 PHP 사이의 다른 특징, 그들의 공동체를 이끄는 기본 철학, 그리고 이러한 기술로 작업할 때 채택된 개념과 표준 방식에 대해 그릴 것이다.

또한 PHP 기반 GraphQL 서버가 GraphQL 사양의 일부가 될 수 없는 사용자 지정 기능을 제공할 수 있는지 살펴보겠다. Graphql-js는 이를 지원할 수 없기 때문이다.

출발하자.

## 1. 지시를 통해 쿼리 해상도 확장 가능

WordPress 애플리케이션은 플러그인을 통해 확장성이 높습니다. GraphQL의 맥락에서, 우리는 플러그인이 다음을 수정할 수 있기를 원할 수 있다.

- 스키마 - 사용자 정의 유형, 기존 유형에 필드 추가 및 지시사항
- 쿼리 해상도 - 필드 값 재정의

이 섹션에서는 두 번째 요소에 대해 살펴보겠습니다. GraphQL 서비스는 쿼리 결과 수정을 어떻게 지원할 수 있습니까?

### 워드프레스 솔루션

WordPress는 후크를 사용하여 동작을 수정합니다. 후크는 값을 재정의하거나 트리거될 때마다 작업을 실행할 수 있는 간단한 코드 조각입니다.

이 예에서 `getBlockCategories` 함수는 `block_categories` 필터에 반응하여 WordPress 편집기에서 활성화된 블록 범주를 수정합니다.

```php
class AbstractBlockCategory
{
  function initialize()
  {
    \add_filter(
      'block_categories',
      [$this, 'getBlockCategories']
    );
  }

  public function getBlockCategories(array $categories): array
  {
    return [
      ...$categories,
      [
        'slug' => 'graphql-api-access-control',
        'title' => __('Access Control for GraphQL', 'graphql-api'),
      ],
    ];
  }
}
```

후크는 간단하고, 다재다능하며, 강력합니다. 후크는 악용될 수 있지만, 잘 구현되면 개발자가 미리 계획하지 않은 방식으로 애플리케이션을 매우 확장시킬 수 있습니다.

### 지시어를 후크로 사용

이 WordPress 솔루션의 영향을 받아, GraphQL에 대한 유사한 솔루션을 검색해 본 결과 지시문은 이에 상응하는 것으로 간주될 수 있다는 결론을 내렸다.

지시어는 WordPress 후크와 같다: 필드의 값을 수정하여 다른 기능을 증강하는 함수이다. 이와는 대조적으로, 그것은 간단하고, 다재다능하며, 강력하다.

예를 들어, 다음 쿼리로 게시물 제목 목록을 검색한다고 가정해 보겠습니다.

```undefined
query {
  posts {
    title
  }
}
```

이 결과들은 영어로 되어 있다. 어떻게 하면 프랑스어로 번역할 수 있을까요? 필드 값을 입력으로 가져오는 필드 `타이틀`에 적용되는 명령 `@translate`는 다음과 같이 Google Translate API를 호출하여 제목을 변환하고 출력을 반환합니다.

```undefined
query {
  posts {
    title @translate(from:"en", to:"fr")
  }
}
```

확장성에 대한 사용 사례는 매우 명확하다. 필드 `제목`에 대한 값이 주어지면 지시어를 통해 원하는 방식으로 수정한다. 이 경우 수정은 @translate를 통해 프랑스어로 번역되는 것이지만 @upperCase와 @lowerCase를 통해 상/하로 변환하는 것일 수도 있다.

하지만 JS 커뮤니티가 제 소신을 공유할까요?

### JS의 지침

나는 (대부분 JS와 함께 일하는) GraphQL 커뮤니티 내에서 나의 이전 솔루션이 널리 받아들여지지 않는다고 생각한다.

이 솔루션을 설명할 때, Reddit에 대한 이 논평에서처럼 질의 지침이 얼마나 형편없는지에 대해 질책을 받을 것입니다.

> 질문 쪽에 광범위한 지시사항이 있는 것이 나에게는 "코드 냄새"처럼 느껴진다.

그 논평 실수는 결국 싸움으로 끝났지만, 저는 😔가 자랑스럽지 않습니다. 심지어 지시도 충성과 적개심, 논쟁의 동기가 될 수 있다니 놀랍군요! 🤣

### 지시어 대신 필드 인수 사용

제가 제안받은 대안 솔루션은 필드 자체에서 다음과 같은 인수를 사용하는 것입니다.

```bash
query {
  posts {
    title(translateFrom: "en", translateTo: "fr")
  }
}
```

저는 이 솔루션이 다른 곳에서도, 예를 들어 여기에서도 강조되고 있다는 것을 알게 되었습니다.

### 지시사항 대신 필드 인수가 있는 문제

저에게 있어서 필드 인수를 사용하는 것은 좋지 않은 해결책입니다. 그것은 번역의 논리와 필드 해결의 논리를 혼합하는 것입니다. 모두 필드 해결사 내에서 말입니다. 효과가 있을지도 모르지만 특별히 우아하지는 않다.

발췌문도 번역해야 한다면 어떻게 될까요? 이 쿼리에서처럼 변경 없이 모든 필드에 쉽게 적용할 수 있기 때문에 지침을 사용하는 것이 매우 쉽습니다.

```undefined
query {
  posts {
    title @translate(from:"en", to:"fr")
    excerpt @translate(from:"en", to:"fr")
  }
}
```

그러나 필드 논리로서는 번역 논리가 필드 `excert`에 대한 해상도를 "오염"할 필요가 있다.

```bash
query {
  posts {
    title(translateFrom: "en", translateTo: "fr")
    excerpt(translateFrom: "en", translateTo: "fr")
  }
}
```

### WordPress가 예상한 확장성에 적합한 기능 분석

서로 다른 기술로 작업하는 개발자들마다 솔루션을 설계하는 방법이 다를 것이며, 이들이 작업하는 한 문제가 없습니다. 옳고 그름은 없습니다.

그러나 당면한 특정 주제(GraphQL 쿼리 해결의 확장성)와 관련하여 지시를 대체하기 위해 필드 인수를 사용하는 것이 항상 작동합니까? 아니면 GraphQL API를 자신의 회사나 특정 클라이언트용으로 코딩할 때처럼 모든 정보를 미리 알 때만 사용할 수 있습니까?

어떤 다른 플러그인이 서비스를 확장할 것인지, 사용자에게 어떤 사용자 지정 요구 사항이 있는지 알 수 없더라도 WordPress가 서비스를 항상 확장할 수 있기를 기대한다면 효과가 있을까요?

그리고 사용자 인터페이스를 통해 기능을 활성화할 수 있다는 WordPress의 극단적인 사용자 친화성을 감안할 때, 코드 라인을 건드리지 않고도 GraphQL 스키마를 확장할 수 있었을까?

아니요, 필드 인수를 사용하면 개발자는 항상 GraphQL 스키마에 어떤 통합이 수행되어야 하는지 알아야 하며 코드를 통해 수행되어야 합니다. 따라서 이 방법론은 워드프레스 방식에는 적합하지 않다.

그러나 지시어를 사용하면 모든 논리가 깔끔하고 우아하게 분리되어 쿼리 자체에서 확장이 가능하며 구성을 통해 스키마에 통합될 수도 있다(이 경우 쿼리 지시문이 클라이언트 측에 노출되는 것을 피할 수도 있다).

### 다른 접근 방식은 어디에서 오는가?

나는 이것이 기술로서의 자바스크립트 대 PHP/WordPress의 문제가 아니라 그들의 근본적인 철학과 작업 방법론에 대한 문제라고 생각한다. JS는 개발자 친화적이지만 워드프레스는 개발자의 편의성보다 최종 사용자의 요구를 우선시한다.

(한편, 최근 WordPress와 Jamstack 간의 경쟁 관계에 대해 비슷한 논의가 활발해졌는데, 이 논쟁은 저만의 의견입니다.)

저로서는, 제가 지시사항을 바탕으로 솔루션을 홍보할 때, WordPress에 매우 도움이 되고 GraphQL에도 똑같이 도움이 되는 "hook을 통해 확장 가능하게 만들기" 철학에서 오는 것입니다.

이 철학은 WordPress용 플러그인 GraphQL API에 깊이 내재되어 있다: 그것은 질의를 해결하기 위해 지시 파이프라인을 사용하며, 지시문은 일류 시민으로 취급된다. 무엇보다도 사용자를 인증하고, 필드의 출력을 제거하며, 파이프라인에서 다음 단계의 실행을 중지할 수 있습니다.

## 2. 네임스페이스를 통한 플러그인 간 충돌 방지

WordPress 디렉토리에 플러그인을 게시하는 개발자는 해당 플러그인을 사용할 사용자 또는 사이트에서 설치할 다른 플러그인을 포함하여 어떤 구성/환경이 있는지 미리 알지 못합니다. 따라서 플러그인은 충돌에 대비해야 하며 충돌을 사전에 방지하려고 시도해야 합니다.

WordPress 플러그인은 충돌을 어떻게 방지합니까?

### PHP의 네임스페이스

갈고리에 대해 다시 이야기합시다. 내 플러그인이 사용자 이름을 수정하기 위해 필터를 추가해야 하는 경우 이 이름은 너무 일반적이므로 "userName"이라고 할 수 없으며 동일한 이름을 사용하는 다른 플러그인이 위험하기 때문입니다. 대신 "GraphQLAPIF for"와 같은 고유한 이름을 붙여야 합니다.WP:userName("사용자 이름")

네임스페이스는 일부 코드를 고유하게 만드는 동일한 역할을 합니다.

네임스페이스는 PHP 커뮤니티 내에서 널리 사용되며, PHP 표준 권장 사항인 PSR-4에 따라 Composer 자동 로드가 가능합니다. PHP 패키지는 벤더 이름을 `vendor-name/package-name`으로 포함해야 하며 해당 네임스페이스가 PHP 코드에 있습니다.

```xml
<?php
namespace VendorName\PackageName;
```

GraphQL 서비스에도 네임스페이스가 적합할까요?

### 그래프의 이름 간격QL

네임스페이스는 GraphQL의 컨텍스트 내에서 타당하여 스키마에 다음과 같은 잠재적 충돌이 발생하지 않도록 합니다.

- 이름이 같은 두 가지 유형 보유
- 이름이 같은 동일한 유형에서 두 개의 필드 보유
- 이름이 같은 두 개의 지시문이 있습니다.

GraphQL 사양에 대해 네임스페이스가 실제로 요청되었습니다.

> 현재 모든 GraphQL 유형은 하나의 글로벌 네임스페이스를 공유합니다. 이는 돌연변이/가입 유형의 모든 필드에도 해당됩니다. GraphQL 스키마에 느슨하게 결합된 여러 부분을 포함할 수 있는 더 큰 프로젝트의 문제가 될 수 있다.

4년여 전 열린 이 문제는 여전히 미해결 상태로 남아 있다. 이바이런(페이스북 근무 시절 그래프QL의 크리에이터 중 한 명)이 이 기능에 반대한다는 입장을 밝혔다. 이 코멘트에서는 Facebook이 GraphQL 스키마의 수천 가지 유형을 충돌 없이 관리하는 방법을 설명합니다.

> 두 가지 방법으로 충돌 이름을 지정하는 것을 피합니다.
통합 테스트. GraphQL 스키마가 파손될 수 있는 어떠한 커밋도 리포지토리에 병합되는 것을 허용하지 않습니다. […]
일반적인 이름 지정 패턴입니다. 우리는 사물의 이름을 붙이는 일반적인 패턴을 가지고 있는데, 이것은 자연스럽게 충돌 문제를 피한다. […]

하지만 궁금한 게 있는데, 페이스북에서 어떤 게 꼭 워드프레스에서도 효과가 있을까?

### Facebook 컨텍스트 대 WordPress 컨텍스트

이 섹션에서는 워드프레스를 자바스크립트와 비교하지 않고 페이스북과 비교한다는 것을 알아두세요. 그러나 페이스북은 그래프QL을 추진하는 최대 이해당사자 중 하나로서 그래프ql-js의 설계 결정에 큰 영향을 미치므로 비교가 타당하다고 생각한다.

Lee Byron은 페이스북이 수천 가지 타입을 관리하기 위해 네임스페이스를 필요로 하지 않는다면, 우리 모두 없이도 할 수 있다고 주장한다.

그러나 다음과 같은 중요한 요소가 있습니다. Facebook은 GraphQL 스키마에 대한 모든 입력을 제어합니다! 이 경우, 충돌이 발생하지 않도록 하기 위해 기업의 이름을 지정하는 절차를 따를 수 있다.

그러나 WordPress는 이렇게 동작하지 않습니다. WordPress 사이트는 타사 플러그인에 크게 의존하며 이러한 플러그인이 생성되는 방식을 제어하지 않습니다.

예를 들어 사이트에서 WooCommerce 및 Easy Digital Downloads 플러그인을 사용하는 경우 GraphQL 스키마에 대해 `Product`라는 유형이 있을 경우 충돌이 발생합니다. 사이트 소유자가 사용할 수 있는 유일한 리소스는 회사 중 한 곳에 연락하여 코드를 수정하도록 요청하는 것입니다. 이것은 예방이 아니라 수정이고, 믿을 수 없습니다.

### 갈등이 정말로 일어날까요?

지금까지 이론에 대해 말해왔지만, 실제로 이 주제를 생각해 봅시다. 갈등이 정말로 일어날까요?

WordPress 플러그인은 사용할 수 있는 플러그인의 수(디렉토리에서만 현재까지 58,000개 이상) 때문에 이름 지정 충돌을 방지하는 데 심각한 주의를 기울여야 합니다. 일부 중복이 발생할 가능성은 무시할 수 없다.

하지만 WordPress에서 GraphQL은 얼마나 인기가 있을까?

불행하게도, 그것의 사용은 아직 널리 퍼지지 않았다. WP REST API를 통해 WordPress 코어에 내장된 REST와 달리 GraphQL은 타사 플러그인에서 설치되어야 한다. 결과적으로, 기관들이 그들의 클라이언트를 위해 테마와 플러그인을 만드는 것 외에, 또는 개인 사이트를 코딩할 때, 개발자들은 WordPress 사이트에서 GraphQL 서비스가 실행될 것이라고 가정할 수 없다.

현재 WordPress에는 두 가지 GraphQL 솔루션이 있습니다.

- WPgrapQL
- WordPress용 GraphQL API (👈 이것은 나만의 것입니다)

우리는 GraphQL 스키마를 확장하는 플러그인에 대해 우려한다. 몇 개입니까?

WordPress 플러그인 디렉토리에서 검색하면 소수의 결과만 생성되며, 200개 이상의 활성화는 없습니다.

GitHub에서 검색하면 10개 이상의 별과 함께 다음과 같은 WPgraphQL 확장자가 생성됩니다.

- wp-graphql/wp-graphql-acf(280개 별)
- wp-graphql/wp-graphql-wocommerce(233개의 별)
- 애쉬히치/wp-그래프ql-요스트서(96성)
- value-digital/wp-graphql-polylang(56성)
- hsimah-services/wp-graphql-hypwp(16성)
- hsimah-services/wp-graphql-hypox(11성)

(WordPress용 GraphQL API에 대한 확장자는 아직 없습니다.)

그렇다면, 아직 WordPress에서 GraphQL이 그렇게 인기가 없다면, 네임스페이스가 필요할까요?

### 그럼에도 불구하고 네임스페이스

지금 당장은 문제가 해결되지 않더라도 네임스페이스가 필요하다고 생각합니다. 그 이유는 다음과 같습니다.

- 충돌을 피할 수 있는 내장 솔루션을 제공하며, 미래에 대한 약속으로 작용하여 플러그인 개발자는 항상 코드가 작동한다는 안심할 수 있습니다.
- GraphQL 스키마를 더욱 우아하게 만듭니다.

마지막 항목에는 다음과 같은 논리가 있다. 우커머스가 충돌이 일어나지 않도록 확실히 하려면 제품, 다운로드, 결제와 같은 그들의 유형에 일반 이름을 사용할 수 없다. 대신 WCP 제품 WCD 다운로드 WCP 결제 등 유형명 자체에 이름을 붙일 필요가 있다. 아니면 언제나 효과가 있을 것이라고 확신하기 위해 우커머스 제품, 우커머스 다운로드, 우커머스 페이먼트 등으로 부를 수도 있다.

음, 그리고 나서 그 스키마는 좀 더 장황해지고, 덜 우아해졌어요. 그것은 가능하다면 피해야 할 것이다.

### 네임스페이스를 자동으로 지원(옵션)

네임스페이스가 실제로 필요하지 않을 수 있으므로 GraphQL 서버에 대한 최상의 전략은 활성화되면 스키마의 모든 유형의 네임스페이스를 자동으로 지정하는 옵션 기능으로 제공하는 것입니다.

이 전략은 다음과 같은 이유로 WordPress용 GraphQL API 플러그인에서 실현 가능하다.

- SDL 우선 접근 방식 대신 코드 우선 접근법을 사용하여 스키마가 코드의 아티팩트로 생성되고 쉽게 재생성될 수 있다.
- 이름을 쉽게 재정의할 수 있도록 PHP 클래스가 아닌 형식 이름을 통해 형식을 참조합니다.

예를 들어, 이 코드에서 `Post.comments` 필드는 해당 PHP 클래스 `CommentTypeResolver`를 참조하여 `Comment` 유형으로 선언합니다.

```php
class CustomPostFieldResolver extends AbstractQueryableFieldResolver
{
  // ...

  public function resolveFieldTypeResolverClass(
    TypeResolverInterface $typeResolver,
    string $fieldName,
    array $fieldArgs = []
  ): ?string {
    switch ($fieldName) {
      case 'comments':
        return CommentTypeResolver::class;
    }

    return null;
  }
}
```

추가 기능 향상으로 플러그인은 사용자가 네임스페이스 유형에 입력할 필요가 없습니다. 대신 모든 PHP 패키지에 대해 기존의 PSR-4 이름을 사용하고 스키마에서 해당 유형에 대해 "벤더 이름\PackageName"을 "VendorName_PackageName"으로 변환합니다(현재 형식 이름 구문에서는 문자 "\"" 또는 "/"가 허용되지 않으므로 "_"가 사용됩니다).

## 3. 표준 이탈: 내포 돌연변이

돌연변이는 게시물 작성, 사용자 이름 업데이트, 게시물에 주석 추가 등 그래프QL 서버의 데이터를 변경할 수 있는 작업입니다.

그래프QL에서 돌연변이는 다음과 같이 `루트 뮤테이션` 유형에서만 노출된다.

```js
type RootMutation {
  createPost(id: ID!, title: String!, content: String): Post!
  updateUserName(userID: ID!, newName: String!): User!
  addCommentToPost(postID: ID!, comment: String!, userID: ID): Comment!
}
```

이 스키마를 사용하면 사용자 이름을 다음과 같이 수정할 수 있습니다.

```bash
mutation {
  updateUserName(userID: 37, newName: "Peter") {
    name
  }
}
```

돌연변이는 GraphQL 규격에서 설명한 것처럼 순차적으로 실행되기 위해 돌연변이 루트 객체 유형에서만 노출된다.

> 돌연변이 연산에서 최상위 필드는 기본 데이터 시스템에 부작용을 수행할 것으로 예상된다. 제공된 돌연변이의 연속 실행은 이러한 부작용 동안 인종 조건에 대해 보장한다.

"시리얼 실행"이라는 용어는 "병렬 실행"과 반대되며, 그렇지 않으면 필드를 해결하는 데 권장되는 동작입니다.

예를 들어 아래 쿼리에서 GraphQL 서버가 먼저 확인하는 필드(`이름`이든 `이메일`이든)는 중요하지 않으며 이러한 필드는 병렬로 해결할 수 있습니다.

```undefined
query {
  user(id: 37) {
    name
    email
  }
}
```

그러나 돌연변이는 데이터를 변화시키므로 필드가 해결되는 순서가 중요하므로, 연속적으로 실행되어야 하며 그렇지 않으면 레이스 조건을 생성할 수 있습니다.

예를 들어, 아래 두 쿼리는 서로 다른 결과를 생성합니다.

```bash
# Query 1: after execution, user name will be "John"
mutation {
  updateUserName(userID: 37, newName: "Peter") {
    name
  }
  updateUserName(userID: 37, newName: "John") {
    name
  }
}

# Query 2: after execution, user name will be "Peter"
mutation {
  updateUserName(userID: 37, newName: "John") {
    name
  }
  updateUserName(userID: 37, newName: "Peter") {
    name
  }
}
```

`루트뮤테이션`을 통해서만 돌연변이를 노출한 결과, 이 유형은 직렬 실행(인터페이스 설계 결정이 아닌 기술적 문제) 외에 다른 공통점이 없는 필드를 포함하면서 심하게 비대해진다.

### 내포된 돌연변이의 경우

위의 돌연변이로 보아, "createPost"만이 "RootMutation" 타입으로 진정으로 살아가고 있다. 왜냐하면 그것은 갑자기 새로운 요소를 창조하고 있기 때문이다. 그러나 `updateUserName` 및 `AddCommentToPost` 돌연변이는 다른 유형의 기존 엔티티에 동일한 작업을 적용할 수 있습니다.

```bash
type User {
  updateName(newName: String!): User!
}

type Post {
  addComment(comment: String!, userID: ID): Comment!
}
```

이 스키마를 사용하면 사용자 이름을 다음과 같이 수정할 수 있습니다.

```bash
mutation {
  user(ID: 37) {
    updateName(newName: "Peter") {
      name
    }
  }
}
```

이 기능을 중첩 돌연변이라고 하는데, 쿼리나 돌연변이 등 다른 작업의 결과에 돌연변이를 적용합니다.

내포된 돌연변이를 사용하면 GraphQL 스키마가 더욱 정교해집니다.

- `RootMutation.updateUserName` 작업은 사용자의 `ID`를 수신해야 하지만 해당 작업 `User.updateName`은 사용자 엔티티에서 이미 실행되었으므로 수신해서는 안 됩니다.
- 필드 이름이 `updateUserName`에서 `updateName`로 단축됨

또한 그래프QL 서비스는 그래프에서 엔티티 사이를 탐색하여 데이터를 쿼리하는 것과 동일한 방식으로 데이터를 수정할 수 있기 때문에 더 간단하고 이해하기 쉽다.

내포된 돌연변이는 여러 단계로 내려갈 수 있습니다. 예를 들어, 새로 작성된 게시물에 대한 주석을 단일 쿼리 내에서 모두 추가할 수 있습니다.

```undefined
mutation {
  createPost(ID: 37, title: "Hello world!", content: "Just another post") {
    id
    addComment(comment: "Lovely post") {
      id
    }
  }
}
```

이로부터 중첩된 돌연변이는 여러 개의 쿼리를 실행하여 여러 요소를 돌연변이를 하는 것에서부터 단일 쿼리를 실행하는 것까지 왕복 지연 시간을 줄임으로써 성능을 향상시킬 수도 있다.

내포 돌연변이는 거의 4년 전에 GraphQL 사양에 대해 요청되었지만, 이 문제는 아직 해결되지 않은 채로 남아 있다(아래에서 살펴보겠다).

### 내포된 돌연변이가 규격의 일부가 아닌 이유

GraphQL 규격은 모든 언어를 위한 GraphQL 서버의 모든 구현에서 작동하도록 되어 있다. 그러나 그 원동력은 기준 구현인 graphql-js를 통한 자바스크립트이다.

즉, `graphql-js`에서 지원할 수 없는 기능은 규격의 일부가 되지 않는다.

자바스크립트가 약속을 지원하기 때문에 필드의 병렬 해상도는 실현 가능했으며, 데이터 로더(데이터 페팅 계층)의 매니페스트처럼 처음 graphql-js를 설계할 때 병렬화는 기본 원칙 중 하나가 되었으며, 배치 함수는 자바스크립트 약속을 반환한다.

성능에 대한 병렬 실행의 이점은 너무 많으며 중첩된 돌연변이는 병렬 처리와 함께 작동할 수 없습니다. 중첩된 돌연변이에 대해 병렬 실행을 거래할 가치가 없다는 결정이 내려졌습니다. 따라서 내포된 돌연변이는 규격에 도달하지 못합니다.

하지만 약속을 지지하지 않는 다른 언어들에게는 어떤 일이 일어날까요?

### 내포된 돌연변이가 PHP에 적합한 이유

PHP는 RetactPHP와 같은 외부 라이브러리를 사용하지 않는 한 자연스럽게 약속을 지원하지 않는다. 따라서 내포된 돌연변이를 지원한다고 해서 이 기능이 처음부터 존재하지 않기 때문에 병렬 실행을 제거하는 부정적인 결과를 초래하지는 않습니다.

즉, PHP 기반 GraphQL 서버는 내포된 돌연변이를 완벽하게 지원할 수 있어야 하며, 모든 이점을 제공하며, 그 결과를 겪지 않아야 한다.

그것은 기회이다. 왜 가져가면 안 되는 거죠?

### 내포된 돌연변이 및 성능

WordPress 플러그인용 GraphQL API의 경우 필드는 항상 직렬로 확인되며, 필드가 해결되는 순서는 결정론적(이 특성은 `@export` 지시어를 지원하는 것을 가능하게 한다)이다.

서버는 쿼리를 확인할 때 그래프 대신 대기열을 사용하여 스키마의 유형 수에 따라 복잡성 시간 `O(n)`를 제공하므로 이 특성은 쿼리 해상도 성능에 영향을 주지 않습니다. 선형 시간으로 그래프QL 쿼리를 해결하는 것은 가능한 한 좋습니다.

이 기사를 쓰면서, 이 플러그인에 대한 내포된 돌연변이의 구현은 진행 중인 작업입니다. 내포된 돌연변이는 GraphQL 규격에서 지원되지 않으므로 이 기능은 비표준 기능이라는 것을 부인하고 옵트인으로 추가됩니다.

## 결론

이 기사에서는 다양한 요소가 JavaScript용 동등한 서버와 비교하여 WordPress용 GraphQL 서버의 특정 요소 구현에 어떤 영향을 미칠 수 있는지 살펴봤습니다.

- WordPress/JS를 사용할 때 사용되는 다른 방법론은 확장 가능한 쿼리 해상도 시스템을 제공하는 아키텍처에 영향을 미칠 수 있다.
- 그래프QL 스키마가 수정될 수 있는 방법과 시기에 대한 다른 철학은 스키마에 네임스페이스를 도입하는 것이 필요한지 여부에 영향을 미칠 수 있다.
- JavaScript와 PHP 사이의 다른 특성은 내포된 돌연변이를 지원하는 것을 정당화할 수 있다.

좋은 해결책도 나쁜 해결책도 없고, 단지 다른 맥락에 더 잘 맞는 해결책일 뿐입니다. 나는 WordPress에 대한 솔루션을 제안하고 시연했는데, 그 철학, 의견, PHP의 기능 등을 고려하여 나는 JavaScript 기반 대안보다 더 잘 작동한다고 믿는다.