---
layout: post
title: "루비에서 크리스탈로 전환해야 하는 이유"
author: "Front Log"
thumbnail: "https://blog.logrocket.com/wp-content/uploads/2020/10/crystal-logo-1.png"
tags: 
---


![image](https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2020/10/crystal-logo-1.png?fit=730%2C487&ssl=1)

## 루비 사랑해? 크리스탈을 시도

루비를 사랑하나요? C처럼 초고속 성능을 갖춘 더 나은 버전의 루비가 있었으면 좋겠어요? 네 기도가 이루어졌구나 크리스탈을 소개합니다. 인터넷은 이것을 "Lick as Ruby, fast as C"라고 부르고 있다.

개발자들은 루비 프로그래밍 언어의 단순성, 개발자 만족도, 생산성에 중점을 두고 있다.

Ruby(및 The Rails 프레임워크)는 Twitter, Github, AirBnB, Shopify, Soundcloud 등을 포함한 지난 10년간 전설적인 스타트업 중 일부를 탄생시켰다.

그러나 루비의 주요 단점은 성능과 확장성이다. 해석된 언어인 루비는 C/C++, Rust, Go만큼 성능이 뛰어나지 않다.

불가능하지는 않지만 Ruby on Rails 애플리케이션을 확장하기는 어렵습니다. 게다가, 루비에 정적 타입이 부족하기 때문에 개발 팀이 성장함에 따라 코드를 리팩터링하기가 어렵습니다. 반면에 크리스탈은 루비의 모든 좋은 부분들을 가지고 있지만 단점은 없다.

✔crystal은 루비처럼 아름다운 구문을 가지고 있습니다.
✔➡Crystal의 성능은 C에 필적합니다.
✔ Crystal은 기본 C 바인딩을 지원합니다.
✔는 메타 프로그래밍을 위한 정적 유형과 강력한 매크로를 제공합니다.
✔ Crystal은 웹 프레임워크와 같은 Rails와 Sinatra를 가지고 있습니다.

크리스탈의 구문은 루비와 거의 비슷하다.

Ruby 코드를 Crystal shell에 직접 쓸 수 있고 그 반대도 가능합니다. 루비처럼 크리스탈은 개발자들을 행복하고 생산적으로 유지하는 데 초점을 맞추고 있다. 루비 개발자들은 크리스탈 구문이 마음에 든다. 예를 들어(Fibonacci 영상 시리즈 함수 🌀):

```undefined
def fib(n)
  if (n<=2)
    return 1
  else
    return (fib(n-1) + fib(n-2))
  end
end
```

이 코드 조각은 Ruby와 Crystal에 대해 동일합니다. 구문이 비슷하기 때문에 이 구문을 다른 구문으로 마이그레이션하는 것은 아주 쉬운 일이다.

Crystal을 설치하고 개발 환경을 설정하는 것도 매우 간단합니다. 모든 Linux 디스트로 또는 Mac에 몇 가지 간단한 명령을 사용하여 Crystal을 설치할 수 있습니다. 여기 공식 안내서를 보세요. 그러나 창에서 Crystal을 실행하려면 Linux 하위 시스템을 설치해야 합니다. 나는 Ubuntu 18.04 이상을 추천한다.

### 놀라운 퍼포먼스탠딩

대부분의 벤치마크에서 크리스탈은 Go, Python 및 Node.js보다 성능이 우수하다. 다음은 Crystal의 성능을 다른 프로그래밍 언어와 비교하는 몇 가지 링크입니다.

🚆👉 성능 벤치마크
🚆👉 성능 비교

Crystal은 LLVM 프레임워크 위에 구축되었습니다. 이것이 크리스탈의 눈부신 연기 비결이다. LLVM은 C/C++ 코드를 바이트 코드로 컴파일하는 것과 동일한 프레임워크이다.

### Crystal의 Easy C 바인딩

Crystal을 사용하면 기존 C 라이브러리와 코드에 쉽게 바인딩할 수 있습니다. 이를 통해 개발자는 네이티브 C 라이브러리로 애플리케이션의 낮은 수준의 작업을 처리할 수 있으므로 성능이 더욱 향상된다.

여기 크리스탈로 C 바인딩을 하는 방법이 있습니다.

C로 다음과 같은 간단한 기능을 작성했다고 가정해 보겠습니다.

```cpp
#include <stdio.h>
void hello(const char * name){
  printf("Say Hello %s!\n", name);
}
```

먼저 gcc-chello.c-o hello.o로 이 파일을 컴파일하고 아래와 같은 Crystal 스크립트로 호출할 수 있습니다.

```undefined
#hello.cr
@[Link(ldflags: "#{__DIR__}/hello.o")]
lib Say 
  fun hello(name : LibC::Char*) : Void
end
Say.hello("to 🔮")
```

### 정적 타이핑

크리스탈의 멋진 특징 중 하나는 정적 타입 시스템이다. 그것은 개발자들이 컴파일 시간에 버그를 잡을 수 있도록 도와준다. 루비나 파이썬과 같은 역동적으로 입력된 언어들은 개발자들이 쉽게 코드를 작성하고 기능을 빠르게 전달할 수 있게 해준다. 그러나 시간이 지나면서 코드 베이스와 팀이 성장함에 따라 이 코드를 리팩터링하고 유지하기 어려워집니다.

크리스탈은 이 문제에 대한 독특한 해결책을 가지고 있습니다.

동적으로 입력되는 언어처럼 크리스탈에 코드를 쓸 수 있습니다. 컴파일러는 불평만 할 뿐이며 모호할 경우 형식을 명시적으로 지정해야 합니다.

### 웹 프레임워크

크리스탈이 사용할 수 있는 웹 프레임워크에 대해 살펴보겠습니다. 레일즈나 피닉스를 좋아한다면 크리스탈을 위한 앰버 프레임워크를 좋아할 것이다.

앰버는 동일한 철도의 레일즈(구성보다 관습)를 기반으로 제작됩니다. 또 다른 유망한 프레임워크는 Rails에서 영감을 받은 Lucky이다. 이 두 프레임워크 모두 놀라운 문서와 함께 코드베이스에 적극적으로 기여하는 열정적인 개발자 커뮤니티를 가지고 있습니다.

반면 플라스크, 익스프레스.js(Node.js), 시나트라와 같은 경량 웹 프레임워크의 팬이라면 케말(Kemal)을 살펴보자. 아직도 납득이 안 돼?

웹 프레임워크에 대한 이러한 성능 벤치마크를 살펴보십시오. 크리스탈 프레임워크는 다른 웹 프레임워크에 비해 성능이 매우 우수하며, 크리스탈 프레임워크의 응답 시간은 밀리초 미만이다.

### 메타프로그래밍은 어때요?

크리스탈은 메타프로그래밍을 위한 강력한 매크로 시스템을 가지고 있다. 기본 템플릿, AST 검사, 유형 검사, 임의 외부 프로그램 실행 등 다양한 용도로 사용할 수 있습니다. [출처: https://crystal-lang.org ]

이 코드 조각을 예로 들어보자. 다음과 같은 간단한 기능으로 모듈, 클래스 및 구조를 생성할 수 있습니다.

```undefined
macro define_class(module_name, class_name, method, content)
  module {module_name}
    class {class_name}
      def initialize(@name : String)
      end
      def {method}
        {content} + @name
      end
    end
  end
end
# This generates:
#     module Foo
#       class Bar
#         def initialize(@name : String)
#         end
#
#         def say
#           "hi " + @name
#         end
#       end
#     end
define_class Foo, Bar, say, "hi "
p Foo::Bar.new("John").say # => "hi John"
```

이 링크를 클릭하면 Crystal 매크로에 대해 자세히 알아볼 수 있습니다.

## 동시성에 대해 이야기해 봅시다.

크리스탈은 동시성을 얻기 위해 섬유라고 불리는 것을 사용합니다. 섬유는 운영체제 나사산과 비슷하지만 가볍다. 실행은 프로세스에 의해 내부적으로 관리됩니다. 프로그램은 여러 개의 섬유를 생성할 수 있으며, 크리스탈은 성능을 최적화하기 위해 그것들을 효율적으로 실행할 것이다.

섬유질은 Go Routine과 매우 유사하다. 다음은 섬유를 산란하는 예입니다.

```undefined
spawn do
  # ...
  socket.gets
  # ...
end
spawn do
  # ...
  sleep 5.seconds
  #  ...
end
```

[출처: https://crystal-lang.org/reference/guides/concurrency.html]

크리스탈은 메모리를 공유하거나 잠금에 대해 걱정할 필요 없이 서로 다른 섬유들 사이의 데이터 통신을 가능하게 한다. Crystal은 CSP(Communication Sequential Process)에서 영감을 얻은 채널을 사용하여 이 작업을 수행합니다.

병렬은 어때요?

현재 크리스탈은 병렬 처리를 지원하지 않습니다. 하지만, 이 팀은 이 기능을 안정적인 버전으로 만들기 위해 노력하고 있습니다.

궁금하고 궁금하다면 동시성 모델에 대한 수정 문서를 언제든지 읽어보세요.

## 그래, 무슨 수를 쓰는 거야?

얼마 동안 소프트웨어를 개발해 왔다면 모든 기술에는 한계가 있다는 것을 이미 알고 있을 것입니다. 크리스탈의 가장 큰 단점은 그것이 새로운 블록의 아이라는 것이다. 많은 사람들은 크리스탈과 그 생태계가 미성숙하고 생산 준비가 되어 있지 않다고 생각한다.

이것이 어느 정도 사실이지만, 그것은 여러분이 이 빛나는 새로운 도구에 적응하기 위해 무리보다 앞서갈 수 있는 가능성을 열어줍니다.
전기차 스타트업 니콜라 모터스는 생산 중인 소프트웨어에 전력을 공급하기 위해 크리스탈을 사용하고 있다. 여기서 그들의 이야기를 읽을 수 있습니다.

크리스탈이 이용할 수 있는 도서관들 또한 다소 제한되어 있다. 크리스탈에 사용할 수 있는 라이브러리는 루비의 Gems 또는 Node의 npm 패키지에 비해 다양하지 않다.

마지막으로, 틈새 제품을 구축하여 매우 구체적인 문제를 해결하려는 경우 설명서를 찾지 못할 수 있습니다. 예를 들어, 저는 크리스탈과 함께 GraphQL 서버를 분리하려고 했습니다. Github에는 몇 가지 좋은 예가 있지만, 나는 이 주제에 대한 어떤 적절한 문서나 튜토리얼도 찾을 수 없었다.

## 결론

크리스탈은 루비의 모든 좋은 부분을 가져오지만 그 어떤 한계도 가지고 오지 않는다. Ruby에서 Crystal로 쉽게 이동할 수 있고, 그 반대의 경우도 마찬가지입니다. 크리스탈은 빠르고 아름다운 루비 같은 구문과 정적 타입, 메타 프로그래밍을 위한 매크로와 같은 강력한 기능을 가지고 있다. 하지만, 모든 기술과 마찬가지로, 크리스탈은 자신만의 한계를 가지고 있습니다.

크리스탈의 주요 한계는 루비, 노드, 파이썬만큼 성숙하지 않다는 것이다. 열정적인 개발자들의 커뮤니티가 커짐에 따라, 크리스탈이 웹 개발의 차세대 주역이 되는 데는 그리 오래 걸리지 않을 것이다. 루비스트로서 크리스탈의 발전을 예의 주시하고 있다는 것을 알고 있습니다.

## 추가 리소스

- 크리스털 랭 공식
- 멋진 크리스탈 기허브 레포
- 케말
- 황색 프레임워크
- Ruby on Rails에서 Rucky on Crystal까지