---
layout: post
title: "콜백에서 올바른 '이것'에 액세스하는 방법"
author: 'Code Tower'
thumbnail: https://blog.logrocket.com/wp-content/uploads/2021/01/access-correct-this-callback.png
tags: undefined
---


![image](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/access-correct-this-callback.png?fit=730%2C487&ssl=1)

자바스크립트를 작성하는 것은 인기 있는 프로그래밍 개념의 독특한 구현으로 인해 신인 개발자와 경험 있는 개발자 모두에게 위협이 될 수 있다. 이 글은 두 가지 까다로운 개념이 동시에 작용하여 의심치 않는 프로그래머를 좌절시키는 시나리오를 다룬다.

- 콜백
- 이것(이것)

이들 각각은 이미 함께 일하기엔 악몽이 될 수 있지만 콜백 안에서 올바른 `이것`에 접근해야 할 때 더욱 까다로워진다. 이 글에서, 우리는 이것을 알아내고 어떻게 우리가 우리의 선택 목적을 가리키도록 컨텍스트 바인딩을 명시적으로 강요할 수 있는지 볼 것이다.

우리가 천천히 걸으려면 콜백이 무엇인지 다시 설명해야 한다.

## 콜백이란?

콜백은 다른 함수에 인수로 전달되는 함수입니다. 일반적으로 콜백은 외부 함수 내의 특정 지점에서 호출됩니다.

> 참고: 콜백에 사용되는 외부 함수를 고차 함수라고 합니다.

콜백은 함수이고 함수는 JavaScript의 개체이므로 콜백에는 고유한 메서드 및 속성 집합이 있습니다. 콜백이 고차 함수 내에서 실행될 때 콜백은 콜백이 정의된 위치/어떻게/언제가 아니라 호출되는 방법에 완전히 종속된 `this` 속성이 할당됩니다.

콜백 내에서 호출되는 고차 함수 내에서 "this" 값을 추적할 수 있습니다. 콜백에서 `이`와 관련된 문제의 대부분은 폐쇄 함수의 실제 정의가 로컬 범위 속성을 가질 수 있기 때문이다. 그러나 콜백 내에서 `이` 바인딩을 사용하여 해당 속성에 액세스하는 경우 콜백의 컨텍스트가 호출 방식에 따라 동적으로 변경되므로 해당 속성이 존재하지 않습니다.

> 팁: 함수(콜백)가 호출되면 JavaScript 인터프리터가 실행 레코드(실행 컨텍스트)를 생성하고 이 컨텍스트에는 함수에 대한 정보가 포함됩니다. 그 중에서도 함수 실행 기간 동안 사용할 수 있는 'this' 참조가 있다.

다음은 콜백 함수의 예입니다.

```js
function HOF(callback){
  callback(); 
}

function callback(){
  console.log(this);
}

HOF(callback) // points to the global Window Object
```

위의 예에서는 HOF(고차 함수)라는 함수가 있으며 이 값을 콘솔에 기록하는 콜백 함수를 사용합니다.

콜백의 컨텍스트가 변경되어 콜백이 호출되는 위치를 확인하기 위해 콜백 내의 `this` 값을 추적하고, 콜백의 `this` 값은 폐쇄 함수 내에서 호출되는 방식에 따라 재할당되는 좋은 예입니다.

> 참고: 폐쇄 함수에 의해 호출되는 콜백에서 '이' 컨텍스트는 변경됩니다. 'this hold' 값은 함수 호출 기능인 호출 사이트에 재할당됩니다.

이 경우 HOF(포함수)가 정의되고 글로벌 범위에서 호출되므로 콜백 내의 this(이) 바인딩은 Window 개체를 가리킵니다.

> 참고: 'Windows' 개체는 브라우저의 열린 창을 나타내는 클라이언트 개체입니다.

다른 시나리오에서 사용될 때 `이` 값의 몇 가지 동작을 살펴보겠습니다.

```js
function bar() {
    console.log(this);
}

bar(); // points to the global Window Object
```

이것은 꽤 간단하다. 막대() 함수는 전역 범위에 있으므로 이 값은 창 개체를 가리킵니다. 그러나 동일한 기능을 사용하여 개체에 대한 메서드로 만든 경우 바인딩이 달라집니다.

```undefined
let sample = {bar: bar};

sample.bar(); // points to the object above
```

이 코드의 출력은 방금 만든 샘플 개체를 가리킵니다. 이것은 아마도 가장 기대되고 직관적인 바인딩일 것이다. 우리는 `이것` 값이 객체의 왼쪽을 가리키는 경향이 있지만 자바스크립트에서 항상 그렇지는 않다.

마지막으로, `새로운` 생성자에 사용될 경우:

```coffeescript
new bar();
```

이 코드의 출력은 `bar.protype`에서 상속되는 객체를 가리킵니다.

함수가 저자 시간에 정의된 모든 속성을 갖는 어휘적 폐쇄 함수를 가리키는 `이` 바인딩이 있어야 하는 내포된 콜백(callback) 상황을 갖기 전까지는 이 모든 것이 매우 간단하다. 그러나 이 시점에서 우리는 함수의 컨텍스트 바인딩이 어휘 선언과 완전히 독립적이며 함수가 호출되는 방법에 따라 결정된다는 사실을 간과하는 경향이 있다.

이렇게 되면 콜백에서 올바른 `이것`에 액세스할 수 없어 발생하는 버그를 해결할 수 있는 몇 가지 방법이 있습니다.

## 콜백에서 올바른 '이것'에 액세스하는 3가지 방법

### 1. 화살표 기능 사용

자바스크립트 화살표 기능은 ECMA스크립트 6에 도입되었다. 전통적인 함수 표현에 대한 간단한 대안이며 고유한 `이` 바인딩이 없습니다. 이렇게 하면 화살표 함수 내에서 "this"에 대한 참조를 사용할 때마다 일반 변수처럼 범위가 조회됩니다.

콜백의 "this" 바인딩에 초점을 맞춘 이 스택 오버플로 문제를 잠시 살펴보겠습니다.

```js
function MyConstructor(data, transport) {
    this.data = data;
    transport.on('data', function () {
        console.log(this.data);
    });
}

// Mock transport object
let transport = {
    on: function(event, callback) {
        setTimeout(callback, 1000);
    }
};

// called as
let obj = new MyConstructor('foo', transport);
```

이는 콜백 내의 this 바인딩이 window 객체를 가리키며 추적 및 디버깅이 어려워 보이는 더 까다로운 시나리오 중 하나이다. 이 코드를 실행하면 `정의되지 않음`이 출력되지만 익명 함수 식을 화살표 함수로 변경하여 이 문제를 쉽게 해결할 수 있다. 그러면 코드는 다음과 같습니다.

```coffeescript
[...]
    transport.on('data', () => {
        console.log(this.data);
    });
}
[...]
```

바로 그것입니다. 함수 선언에서 몇 개의 문자를 변경하는 것만큼 쉽습니다. 그리고 우리는 `이` 바인딩 문제를 해결했습니다.

### 2. 'this' 객체를 저장할 다른 변수 생성

대부분의 경우 콜백에서 "이것"에 액세스하려고 할 때, 우리가 정말로 액세스하기를 원하는 것은 그것이 가리키는 객체이다. 이를 달성하기 위한 방법은 변수를 생성하여 콜백 범위 바로 앞에 `이` 값을 저장하는 것이다(일부 프로그래머는 이 값이 지저분해 보이므로 저장하지 않는 것이 좋다).

나는 몇몇 사람들이 그것을 `그것` 또는 `자기`라고 부르는 것을 본 적이 있지만, 그것이 충분히 직관적인 한 그것은 정말로 어떤 것으로 불리는지는 중요하지 않다. 이 해킹은 변수가 어휘 범위의 규칙을 준수하므로 콜백 내에서 액세스할 수 있기 때문에 작동한다. 이 방법의 또 다른 이점은 콜백의 동적 `이` 바인딩이 무엇이든 여전히 액세스할 수 있다는 것입니다.

다음은 위의 조각을 사용하는 경우의 예입니다.

```js
function MyConstructor(data, transport) {
    this.data = data;
    let that = this;
    transport.on('data', function() {
        alert(that.data);
    });
}
```

이것은 앞의 해결책과 마찬가지로 콜백 안에서 `이것`에 접근하는 문제를 해결한다.

### 3. '이것'을 물체에 명시적으로 바인딩

콜백(Callback)을 정의할 때 `이`가 무엇이었으면 좋겠다고 명시적으로 지정할 수 있습니다. bind() 방법을 사용하면 이 값을 설정하고 함수 호출 또는 전달 위치에 관계없이 실행 중에 이 값을 유지할 수 있습니다.

모든 함수는 지정된 객체에 바인딩된 "this" 속성을 가진 새로운 함수를 반환하는 "bind()" 메서드를 가집니다. 반환된 함수는 원래 함수와 동일한 동작을 갖습니다. 유일한 차이점은 `이` 속성이 가리키는 것을 완전히 제어할 수 있다는 것입니다.

동일한 코드 조각을 예로 들어 보겠습니다.

```js
function MyConstructor(data, transport) {
    this.data = data;
    let boundFunction = (function() { 
        alert(this.data);             
    }).bind(this); // we call bind with the `this` value of the enclosing function
    transport.on('data', boundFunction);
}
```

이렇게 하면 문제가 해결되고 콜백의 `이` 구속력을 크게 제어할 수 있게 된다.

## 결론

우리는 현대 자바스크립트에서 가장 까다롭고 위압적인 두 개념을 표면적으로 탐구해 왔습니다. 콜백이 있는 코드베이스 내에 있을 때 잘못된 콜백에 액세스하는 것처럼 보일 때마다 고차 함수 내에서 콜백의 실행을 추적하여 고차 함수를 호출하는 방법에 따라 콜백 바인딩이 무엇인지에 대한 단서를 찾으십시오.

만약 그것이 실패하거나 어려운 것으로 판명되면, 이 위협을 시정하기 위한 당신의 무기 기술을 기억하라.