---
layout: post
title: "자바스크립트 '레코드'와 '투플' 제안서: 개요"
author: 'Code Tower'
thumbnail: https://blog.logrocket.com/wp-content/uploads/2021/01/javascript-record-tuple-proposal.png
tags: undefined
---


![image](https://i0.wp.com/blog.logrocket.com/wp-content/uploads/2021/01/javascript-record-tuple-proposal.png?fit=730%2C487&ssl=1)

## 도입

ECMA 스크립트인 레코드와 튜플 제안서는 자바스크립트에 레코드와 튜플이라는 두 가지 새로운 데이터 구조를 도입한다. 이러한 데이터 구조를 통해 JavaScript에서 처음 두 개의 복합 원시 값을 생성할 수 있습니다.

복합 원시성은 문자열, 숫자 및 부울과 같은 단순한 원시 요소뿐만 아니라 레코드 및 튜플도 포함할 수 있는 다른 구성 요소 값으로 구성됩니다.

복합 원시 요소 유형을 포함한 원시 요소에는 몇 가지 뚜렷한 특징이 있습니다. 첫째, 그것들은 매우 불변하며, 이것은 그들이 원래의 가치의 복사본이 아니라 새로운 가치를 완전히 반환하기 때문에 우리가 비원수적(예: 물체)을 바꿀 수 있는 방법을 바꿀 수 없다는 것을 의미한다.

또한, 그들의 불변의 성질 때문에, 우리는 더 많은 보증과 함께 엄격한 평등 운영자(`===`)를 사용하여 그들을 비교할 수 있다. 즉, 이러한 데이터 유형은 컨텐츠에 의해 엄격하게 비교될 수 있으며, 동일한 구성 요소를 포함하는 데이터 유형도 동일하다고 확신할 수 있습니다.

## JavaScript의 불변성에 대한 이전 발전

이전에는 불변 데이터 구조에 대한 ECMA 스크립트 제안이 검토되었지만, 일부 관련 복잡성과 충분한 사용 사례 부족으로 인해 결국 폐기되었다.

오늘날, 사용자들은 언어의 객체와 배열에 대한 깊은 불변성을 처리하기 위해 Implicable.js와 Immer와 같은 라이브러리에 의존한다. 예를 들어, 임머의 접근 방식은 냉동된 물체를 생성하는 것에 의존한다. 그러나 이러한 라이브러리를 사용하면 몇 가지 잠재적인 문제가 발생할 수 있습니다.

첫째, 같은 일을 하는 방법이 잘 상호 작용하지 않는 다른 방법이 있다. 또한 이러한 라이브러리에 사용되는 구문은 JS에 기본적으로 통합되었을 때처럼 인체공학적이지 않다. 마지막으로, 이러한 라이브러리가 외부 유형 시스템과 잘 작동하도록 하는 것은 어려울 수 있다.

이 새로운 레코드와 튜플 제안으로 원초적인 것에만 기반을 두고 있기 때문에 확실하고 표준적인 업무 처리 방법이 있다. 원시 요소에만 기초할 레코드와 튜플을 설계함으로써, 제안은 이러한 라이브러리에서 도입된 복잡성을 제거하는 동시에 비교를 위한 명확한 방법을 정의한다.

## 레코드와 튜플 제안서 자세히 보기

이 제안은 현재 TC39 프로세스의 2단계에 있는데, 이는 여전히 진행 중인 작업이며 커뮤니티의 피드백에 따라 변경될 가능성이 높다는 것을 의미한다. 그것은 TC39 멤버 로빈 리카드와 블룸버그의 릭 버튼에 의해 주도되었다.

제안서에 따르면, 기록과 튜플은 각각 객체와 배열의 깊은 불변 버전이다. 본질적으로, 레코드는 객체와 유사한 구조를 가지도록 설계된 반면, 튜플은 배열과 같은 구조를 가지고 있다. 앞서 언급했듯이, 기록과 튜플은 다른 기록과 튜플을 포함한 원시적인 요소만 포함할 수 있습니다.

### 구문

레코드와 튜플은 현재 앞의 "#" 수식어를 사용하여 선언됩니다. 이것이 언어에서 객체 및 배열 선언과 구별되는 점입니다. 이러한 새 데이터 유형을 정의하기 위해 현재 제안된 구문의 몇 가지 예를 살펴보겠습니다.

선언 기록:

```php
const rec1 = #{} // an empty record
const rec2 = #{ a: 1, b: 2 } // a record containing two KV pairs
const rec3 = #{ a: 1, b: #[2, 3] } // a record with two elements including a tuple containing 2 elements
```

튜플 선언:

```php
const tup1 = #[]  // an empty tuple
const tup2 = #[1, 2]  // a tuple containing two elements
const tup3 =#[1, 2, #{ a: 3 }] // a tuple with three elements including a record containing 1 element
```

제안된 구문은 이미 언어(예: 개인 클래스 필드)의 다른 곳에서 사용되고 있지만 객체 및 어레이 리터럴의 구문과 유사하므로 사용자가 이해하기에 그리 어렵지 않을 것이다. 이에 따라 완전히 새로운 키워드를 사용하거나 `{|}` 및 `[|]`와 완전히 다른 구문을 사용하는 것에 대한 논의가 이루어지고 있다.

> 참고: 가능한 구문 오류에 대한 자세한 내용은 제안 문서의 이 섹션을 참조하십시오.

## 레코드 및 튜플 탐색

아래에서는 이러한 새로운 데이터 유형에 대해 자세히 살펴보겠습니다.

### 기록.

우리가 언급했듯이, 기록들은 사물들과 비슷하지만, 그것들은 매우 불변합니다. 레코드의 구문은 앞의 `#` 기호를 사용하여 객체를 정의하는 방식과 유사합니다. 아래 샘플 레코드를 선언합니다.

```undefined
const rec1 = #{ a: 10, b: 20, c: 30 }
```

다시 말하지만, 레코드에서 원시 유형만 속성으로 사용할 수 있습니다. 따라서 튜플과 다른 기록들은 모두 원시적이기 때문에 기록 내부에 둘 수 있습니다. 예를 들어:

```undefined
const rec2 = #{x: #[1,2,3], y: #{ a: 10, b: 20, c: 30 }
```

> 참고: 원시 데이터 유형을 제외한 모든 유형이 포함된 레코드 또는 튜플을 생성하려고 하면 'typeError'가 발생합니다. 깊은 불변성에 대한 설계 결정에 대한 자세한 내용은 여기에서 확인할 수 있습니다.

#### 레코드가 있는 개체 메서드

또한 객체 방법을 레코드와 함께 사용할 수 있습니다. 예를 들어 위의 예에서 개체 스프레드 구문을 사용합니다.

```coffeescript
const rec3 = #{x: #[1,2,3], ...rec2}

console.log(rec3) 
// rec3 return value
#{x: Tuple, y: Record}
        1. ▶x: Tuple
            1.  0: 1
            2.  1: 2
            3.  2: 3
        2. ▶y: Record
            1.  a: 10
            2.  b: 20
            3.  c: 30
```

또 다른 예로 위의 `rec3` 레코드의 키를 놀이터의 콘솔에 로깅하여 추출해 보겠습니다.

```coffeescript
console.log(Object.keys(rec3))
// ["x", "y"]
   1.  0: "x"
   2.  1: "y"
```

아래 그림과 같이 표준 방법을 사용하여 레코드에 파괴를 적용할 수도 있습니다.

```cpp
const {name, ...rest} = #{ name: "Alex", occupation: "Farmer", age: 98 };

console.log(name); // Alex
console.log(rest); // Object {age: 98, occupation: "Farmer"}
console.log(#{...rest}); // Record #{age: 98, occupation: "Farmer"}
```

일반 객체의 속성에 액세스할 수 있는 것처럼 레코드에서도 동일한 작업을 수행할 수 있습니다.

```coffeescript
console.log(rec3.x); // #[1, 2, 3]
```

### 튜플스

튜플은 JavaScript의 어레이와 유사하지만, 다시 말해, 그것들은 매우 불변합니다. 다음 구문을 다시 살펴보겠습니다.

```undefined
const tup1 = #[1, 2, 3, 4]
```

#### 튜플이 있는 배열 방법

레코드가 개체 메서드를 지원하는 것과 마찬가지로 튜플도 어레이 메서드를 지원합니다. 예를 들어 어레이와 마찬가지로 요소의 위치 또는 인덱스에 액세스할 수 있습니다.

```cpp
console.log(tup1[1]) // 2
```

또한 스프레드 연산자를 사용하여 두 개의 튜플을 결합할 수 있습니다.

```undefined
const tup2 = #[5,6,7,8,9]

const tup3 = #[...tup1, ...tup2];

console.log(tup3) // #[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

튜플은 또한 다음과 같은 표준 배열 방법을 지원합니다.

```cpp
const tup = #[1, 2, 3]
console.log(tup.map(x => x * 2)); 
// #[1, 2, 3] 
```

> 참고: 'Tuple.protype.map'에 대한 콜백은 원시 요소만 반환할 수 있습니다.

마찬가지로 아래 표준 방법을 사용하여 튜플에 파괴를 적용할 수 있습니다.

```cpp
const [head, ...rest] = #[1, 2, 3];

console.log(head); // 1
console.log(rest); // Array [2, 3]
console.log(#[...rest]); // Tuple #[2, 3]
```

일반적으로 개체와 어레이는 자바스크립트에서 레코드와 튜플을 효과적으로 사용하기 위해 동일한 방법을 지원하지만, 일부 경우에는 미묘한 차이가 있으며, 나중에 탐색할 것이다.

> 참고: 레코드와 튜플은 맵의 키 및 세트의 요소로서 마찬가지로 중요합니다. 제안서에 따르면, 지도와 세트는 언어의 원시적 형태 특성상 기록과 튜플과 함께 사용하면 더욱 강력해진다.
또는 레코드와 튜플을 '취약 맵'의 키 또는 '취약 집합'의 값으로 사용할 수 없습니다. 원시 요소가 허용되지 않기 때문에 (비취약) 맵의 키로 사용하는 것이 거의 타당하지 않기 때문이다.
또한 이러한 경우 원시적이지 않기 때문에 개체 유형만 사용해야 한다는 점에 유의해야 합니다. 이 주제에 대한 자세한 내용은 제안 문서에서 확인할 수 있습니다.

### 레코드/튜플 데이터 유형의 동일성

이 새로운 제안으로, 우리는 참조 또는 아이덴티티로만 비교할 수 있는 객체나 배열과는 달리 값별로 복합 원시 요소를 쉽게 비교할 수 있다. 아래 레코드와 튜플을 사용한 몇 가지 예를 살펴보겠습니다.

튜플 및 레코드 비교:

```coffeescript
console.log(#{x: 1, y: 4} === #{y: 4, x: 1})
//true

console.log(#['a', 'b'] === #['a', 'b'])
//true
```

개체 및 어레이 비교:

```coffeescript
console.log({x: 1, y: 4} === {x: 1, y: 4})
//false 

console.log(["a", "b"] === ["a", "b"])
//false
```

우리가 볼 수 있듯이, 기록과 튜플은 비교할 때 항상 서로 같습니다. 반면에 개체와 배열은 앞에서 설명한 것처럼 원시적이지 않기 때문에 동일하지 않습니다.

본질적으로, 기록과 튜플의 구조와 내용이 동일하면 제안서에 따르면, 그 값은 엄격한 평등(===) 운영에 따라 동등하다고 간주된다. 또한 위의 예에서 볼 수 있듯이, 레코드 키의 삽입 순서는 객체와 달리 레코드의 동일성에 영향을 주지 않는다.

> 참고: 이러한 데이터 유형에는 엄격한 평등이 중요하므로 사용자는 어떤 레코드/튜플이 조작되고 있는지, 어디서 생성되었는지에 대해 걱정할 필요가 없습니다. 즉, 예측 가능한 동작을 보장합니다.

### 튜플 및 레코드를 통해 반복

어레이와 마찬가지로 튜플도 사용할 수 있습니다.

```cpp
const tup = #[1,2,3]

for (const o of tup) { 
console.log(o);  
}

// 1,2,3
```

또는 객체와 유사하게 레코드는 `Object.entry`와 같은 API와 함께만 사용할 수 있습니다.

```undefined
const rec = #{z: 1, a: 2 }

// Object.entries can be used to iterate over Records, just like with Objects
for (const [key, value] of Object.entries(rec)) { 
console.log(key) 
}

//  1. "a" 2. "z"
```

### 레코드 및 튜플을 일반 개체/레이로 변환

레코드를 JS의 개체로 다시 변환하려면 "Object" 생성자를 둘러싸기만 하면 됩니다.

```cpp
const rec = #{x: 1, y: 4})
console.log(Object(rec)
// returns an Object {x: 1, y: 4} 
```

마찬가지로 튜플을 어레이로 변환하려면 `Array.from` 방법만 사용하면 됩니다.

```cpp
const tup = #['a', 'b']
console.log(Array.from(tup))
// returns an array  ['a', 'b']
```

### 개체 및 어레이에서 변환

우리는 각각 레코드()와 튜플() 방법을 사용하여 객체와 배열을 레코드와 튜플로 변환할 수 있다. 기록()과 Tuple.from()은 기록, 튜플 또는 기타 원시 요소에서만 작동합니다. 몇 가지 예를 봅시다.

기록의 경우:

```cpp
const obj = { a: 1, b: 2, c: 3 }
const rec1 = Record(obj);
console.log(rec1)
//#{ a: 1, b: 2, c: 3 }
```

예:

```cpp
const arr = [1, 2, 3]
const tup = Tuple.from(arr); 
console.log(tup)
//#[1, 2, 3]
```

> 참고: 중첩된 개체 참조에 현재 초안 제안에는 재귀 변환 루틴이 포함되어 있지 않으므로 'TypeError'가 발생할 수 있습니다.

### 튜플을 사용한 배열 방식 조작

이 경우에는 `Tuple.prototype`입니다.push는 array.protype을 사용하는 것과 비슷하다.push. 그러나 튜플에 대한 이러한 작업은 항상 새로운 수정 버전을 반환하기 때문에 불변합니다.

```coffeescript
const tup1 = #[1, 2];
console.log(tup1.pushed(3)) // #[1, 2, 3]
```

마찬가지로 `투플.프로토타입`입니다.sorted` 메서드는 `Array.protype`을 사용하는 것과 유사합니다.언어로 `방법 정렬:

```coffeescript
const tup2 = #[3, 2, 1]
console.log(tup2.sorted) // #[1, 2, 3]
```

### 레코드/튜플의 JSON.parseImbulable 및 JSON.stringify

이 제안에는 JSON 문자열에서 레코드나 튜플을 추출할 수 있는 JSON.parseImbulable이 추가됐다. JSON.parse가 객체와 배열에서 작동하는 방식과 유사하다.

> 참고: 작성 당시 운동장은 JSON.parseImbulable을 지원하지 않습니다.

또한 레코드와 튜플에서 JSON.stringify의 동작은 각각 JSON.stringify가 객체 또는 배열에서 작동하는 것과 같다.

레코드의 `JSON.stringify`

```coffeescript
const rec = #{ a: #[1, 2, 3] }

console.log(JSON.stringify(rec));

//"{"a":[1,2,3]}"
```

개체의 `JSON.stringify`:

```js
const obj = { a: [1, 2, 3] }

console.log(JSON.stringify(obj));

//"{"a":[1,2,3]}"
```

자세한 내용은 제안 문서에서 확인할 수 있습니다. 또한, 이 기사의 모든 예는 여기 놀이터에서 찾을 수 있습니다.

## 결론

레코드와 튜플 제안은 여전히 진행 중인 작업이다. 현재로서는 두 가지 모두 깊은 불변성을 기본적으로 해결하기 위한 실험적인 특징입니다. 오늘날, 사용자들은 깊은 불변성의 경우를 처리하기 위해 Implicable.js와 Immer와 같은 라이브러리에 의존한다. 하지만 앞서 말씀드린 바와 같이, 이것은 차후에 문제를 일으킬 수 있습니다.

이 제안 설계는 레코드와 튜플의 모든 것이 객체나 배열과 같지 않기 때문에 일반적인 프로그래밍 오류에 대한 보증을 제공한다. 이 설계는 기록과 튜플이 변하지 않도록 한다.

본질적으로, 레코드와 튜플의 구조는 `객체`를 사용하는 것과는 반대로 보장된다.얼다. 우리가 알다시피, `객체`입니다.freeze는 얕은 작업만 수행할 뿐 개체나 배열과의 엄격한 동일성을 보장하지는 않는다. 따라서 언어에 대한 기본적 불변성이 있기 때문에 객체나 배열에 대한 얕은 복제를 제공하는 라이브러리에 의존할 필요가 없습니다.

이번 제안서 소개에서는 이러한 데이터 유형의 기본 사용 사례와 사용 방법에 대한 몇 가지 예를 다룰 수 있었습니다. 자세한 내용은 GitHub에서 사양, 요리책, 공식 튜토리얼 등 제안서 링크를 참조하십시오.

레코드의 심층 경로 속성을 추가하는 후속 제안도 확인할 수 있습니다. 마지막으로, 이 튜토리얼에서 다룬 예제를 연습하려면 운동장을 확인하십시오.