---
layout: post
title: "CSS 컨텐츠 가시성을 사용하여 렌더링 성능 향상"
author: 'Code Tower'
thumbnail: https://blog.logrocket.com/wp-content/uploads/2020/12/using-content-content-visibility-property-CSS.png
tags: undefined
---


![image](https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2020/12/using-content-content-visibility-property-CSS.png?fit=730%2C487&ssl=1)

개발자는 일반적으로 웹 사이트를 개선하고 최적화하는 것을 목표로 할 때 렌더링 성능을 우선시하지 않습니다.

결국 서버 응답 시간 향상, 파일 크기 감소, 파일 로드의 우선 순위 지정과 같은 다른 최적화도 있어 즉각적인 개선 효과를 제공합니다. 또한, 렌더링이란 웹 개발자들이 직접 접근할 수 없는 브라우저의 내부 프로세스이다.

그러나 개발자는 다음 세 가지 주요 이유로 렌더링에 집중해야 합니다.

- 렌더링 기능은 최신 웹 사이트의 작동 방식에 필수적인 부분입니다. 차단 작업이므로 모든 사용자 상호 작용을 차단합니다.
- 렌더링 성능의 결과는 모바일 기기, 특히 하위 기기에서는 매우 분명합니다.
- 브라우저가 콘텐츠를 보다 효율적으로 렌더링할 수 있도록 지원하는 직접 및 간접적인 방법이 있습니다.

새로운 CSS `콘텐츠-가시성` 속성 덕분에 브라우저 렌더링 프로세스에 영향을 미치는 일은 훨씬 더 쉬워졌다. 기본적으로 이 속성은 요소의 가시성을 변경하고 렌더링 상태를 관리합니다.

이미 존재하는 디스플레이, 가시성 등의 특성과 다소 유사하다. 그러나 콘텐츠-가시성은 그것과는 다르게 동작한다.

이번 블로그 게시물에서는 콘텐츠 가시성, 렌더링 성능, 디스플레이와 가시성 특성 비교에 대해 알아본다.

## 컨텐츠 가시성이 렌더링 성능을 향상시키는 방법

콘텐츠-가시성의 핵심 기능은 우리가 선택한 HTML 요소의 렌더링을 연기할 수 있게 한다는 것이다. 기본적으로 브라우저는 사용자가 볼 수 있는 DOM 트리 내의 모든 요소를 렌더링합니다.

사용자는 뷰포트에 적합한 요소를 볼 수 있으며 스크롤을 통해 페이지 내의 다른 요소를 볼 수 있습니다. 모든 요소를 한 번에 렌더링하면 브라우저가 페이지 레이아웃과 스크롤 막대를 페이지 전체에서 일정하게 유지하면서 페이지의 치수를 올바르게 계산할 수 있습니다.

브라우저가 페이지 내 요소 중 일부를 렌더링하지 않으면 페이지 높이를 올바르게 계산할 수 없기 때문에 스크롤이 악몽이 될 수 있습니다. 아니면 그럴까?

두려워 말라. 콘텐츠 가시성은 요소가 사용자의 뷰포트 내에 있는지 여부를 감지하고 아직 뷰포트에 들어가지 않은 요소의 렌더링을 건너뛰는 자동 옵션이 있다.

이는 사용자가 처음에 화면 외부에 있는 요소를 볼 수 없기 때문에 이 요소가 초기 페이지 로드 중에 불필요하다는 것을 의미하기 때문입니다. 따라서 이러한 요소의 렌더링을 연기하면 초기 렌더링 시간이 줄어들어 사용자가 콘텐츠를 더 빨리 볼 수 있습니다.

## 컨텐츠 가시성의 검정력 측정

물론, 이론적으로는 다 좋지만, 더 깊이 파고들자. 그래서 저는 컨텐츠-가시성의 힘을 최대한 정확하게 측정하기 위해 데모 블로그를 만들었습니다.

블로그는 텍스트, 이미지, 그리고 다양한 HTML 요소들을 가지고 있기 때문에 이것을 위한 좋은 테스트 케이스이다. 블로그 페이지는 긴 경향이 있으므로, 종종 폴더 아래에 렌더링 지연의 이점을 얻을 수 있는 일부 콘텐츠가 있습니다. 또한 콘텐츠는 일반적으로 정적이기 때문에 메트릭스에 영향을 미칠 수 있는 동적 콘텐츠는 고려하지 않아도 됩니다. 초기 페이지 로드에만 집중할 수 있습니다.

이런 생각들을 염두에 두고 블로그를 수정해 한 가지 중요한 차이점만 빼면 한 가지 중요한 점은 콘텐츠-가시성-자동(auto)이 켜졌다는 것이다.

저는 크롬의 저가 휴대폰 에뮬레이션에 대한 벤치마크를 실행하기로 결정했습니다. 최신 하이엔드 노트북에는 두 버전 간의 차이를 명확히 알 수 없을 정도로 처리 능력이 뛰어납니다. 유사한 결과를 가진 여러 벤치마크를 실행했습니다. 아래에서는 각 버전의 블로그에 대한 예제 벤치마크를 볼 수 있습니다.

이 벤치마크는 콘텐츠 가시성을 사용할 경우 렌더링 시간이 50MS 단축됨을 보여준다. 그것은 모바일 사용자들이 좋아할 만한 상당히 개선된 것이다.

두 버전의 블로그를 모두 온라인으로 사용할 수 있으므로 벤치마크를 직접 실행할 수도 있습니다.

- 컨텐츠 가시성 사용 안 함
- 컨텐츠 가시성 사용 시

## 컨텐츠 가시성 구현 방법

컨텐츠-가시성의 이점을 얻는 것은 어렵지 않다. 먼저 페이지의 내용 가시성 부분을 파악하는 것부터 시작합니다. 아래 스크린샷에서는 사용자가 즉시 볼 수 있는 콘텐츠(예: 폴드 이상의 콘텐츠)와 스크롤을 통해 연결할 수 있는 콘텐츠를 식별했음을 확인할 수 있습니다. 아래 접힌 내용의 렌더링을 연기하면 초기 렌더링 시간이 단축됩니다.

![image](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2020/12/content-visibility-rendering-above-the-fold.png?resize=730%2C562&ssl=1)

아래 내용에 대해 `콘텐츠 가시성: 자동`을 설정하면 브라우저가 해당 콘텐츠의 렌더링을 볼 수 있을 때까지 연기하는 렌더 최적화 기능이 트리거됩니다. 이 작업을 수행하기 위한 코드는 다음과 같습니다.

```css
.below-the-fold {
  content-visibility: auto;
}
```

이것은 우리가 원하는 렌더링 동작을 달성하지만 한 가지 작은 문제가 있습니다. 페이지 높이가 올바르게 계산되고 스크롤이 일정하게 유지되도록 하기 위해 처음에 모든 콘텐츠를 렌더링해야 한다고 말했던 것을 기억하십니까? 이제 우리는 이 문제를 가지고 있습니다.

기본적으로 `콘텐츠 가시성`은 할당된 요소의 `높이`를 0으로 처리합니다. 브라우저는 이 요소가 렌더링될 때까지 `높이` 0으로 만들어 보이지 않게 만들며, 이 요소는 페이지 높이와 스크롤을 망칩니다.

그러나 이 동작은 요소 또는 하위 요소에 이미 `높이`가 할당되어 있으면 무시되므로, 하위 요소에서 이미 `높이` 속성이 설정되어 있으면 문제가 되지 않습니다.

요소에 `높이` 속성이 없고 부작용으로 인해 추가하지 않으려는 경우, `포함수-내성 크기` 속성을 사용하여 요소가 올바르게 렌더링되도록 하는 동시에 렌더링 지연의 이점을 유지할 수 있습니다. 이렇게 하면 다음과 같은 코드가 생성됩니다.

```css
.below-the-fold {
  content-visibility: auto;
  contain-intrinsic-size: 240px;
}
```

여기 보이는 `240px` 값은 한 예일 뿐입니다. 그것은 우리가 `콘텐츠-가시성`을 사용할 요소의 실제 높이로 대체되어야 한다.

불행히도, 전체 아래 내용에 대한 단일 값을 계산하는 것은 어렵습니다. 페이지는 해당 페이지에 표시된 항목을 기준으로 길거나 짧을 수 있습니다. 따라서 예측 가능한 `높이`를 가진 요소에 이 속성을 추가할 것입니다. 예를 들어, 우리의 예시 블로그의 기사들은 꽤 표준적인 외모를 가지고 있다.

블로그의 기사마다 높이가 468px다. 이제 container-intrinic-size를 468px로 설정하여 사례를 완성할 수 있다.

```css
.below-the-fold {
  content-visibility: auto;
  contain-intrinsic-size: 468px;
}
```

## 컨텐츠 가시성(content-visibility

오토 옵션은 분명 놀라운 일을 하지만 한 걸음 더 나아가는 것은 가능하다. 콘텐츠-가시성은 우리에게 숨김(hidden)과 기억(hidden)이라는 두 가지 잠재적 가치를 더 제공한다. 이 값들은 `콘텐츠 가시성`이 할당된 요소를 숨기거나 표시할 것으로 예상되는 작업을 수행합니다. 이러한 값은 고급 사용 사례에 유용할 수 있습니다.

이러한 경우 중 하나는 `디스플레이` 속성이 사용되는 방식과 유사하게 프로그래밍 방식으로 요소를 표시하거나 숨기는 것이다. 이 경우 콘텐츠 가시성은 모델이나 팝업 등 자주 표시하거나 숨기는 항목의 렌더링 성능을 향상시킬 수 있다. 콘텐츠-가시성은 숨겨진 가치가 다른 것과 어떻게 다르게 기능하는가를 통해 이러한 성과를 높일 수 있다.

## 콘텐츠-가시성-숨김이 대안과 어떻게 비교되는가.

`표시: 없음`: 이렇게 하면 요소가 완전히 숨겨지고 렌더링 상태가 사라집니다. 요소를 다시 표시하려면 브라우저가 다시 렌더링해야 하는데, 비용이 많이 듭니다.

`가시성: 숨김`: 이것은 단순히 요소를 보이지 않게 만듭니다. 요소가 `숨겨진` 경우에도 브라우저는 필요할 때 다시 렌더링할 수 있습니다. 요소와 그 하위 항목도 페이지의 빈 공간을 눈에 띄게 유지합니다.

`콘텐츠-가시성:숨김: 이렇게 하면 요소는 숨겨지지만 렌더링 상태는 유지됩니다. 표시장치: 없음과 같이 동작하지만 다시 표시하는 데 드는 비용은 훨씬 낮다는 뜻이다.

물론 이것이 우리에게 더 이상 디스플레이나 가시성이 필요하지 않다는 것을 의미하지는 않는다. 아직 사용 사례를 보유하고 있지만, 이제 활용할 수 있는 추가 툴이 있습니다.

## 컨텐츠 가시성을 위한 브라우저 지원

콘텐츠-가시성은 아직 작업 초안 단계이기 때문에 다른 사람들에 비해 지원이 다소 늦어질 것으로 보인다. 현재는 크롬과 에지 버전 85만 지원한다. 즉, 이러한 최적화 구현의 이점을 최대한 활용하려면 시간이 좀 더 걸릴 것입니다.

반면에, 이 CSS 속성의 `자동` 기능은 순전히 성능 최적화를 위한 것이다. 그것은 어떤 시각적 변화도 일으키지 않는다. 브라우저에서 지원하지 않을 때는 부정적인 영향을 주지 않고 그냥 무시되기 때문에 모든 브라우저에 대해 구현하고 더 많은 브라우저에서 지원되므로 동작을 관찰하는 것이 안전하다.

현재 브라우저 지원은 여기에서 확인할 수 있습니다.

## 결론

컨텐츠-가시성은 매우 적은 작업에도 확실한 이득을 약속한다. 자동 기능은 오늘날 우리가 구현하고 혜택을 받기 시작할 수 있는 것이다. 그러나 디스플레이(display)나 가시성(visibility)을 대체하기 위해서는 콘텐츠 가시성이 대부분의 최신 브라우저에서 지원될 때까지 기다려야 한다.

컨텐츠 가시성: auto(자동)를 시도하여 어떻게 작동하는지 알려 주십시오!