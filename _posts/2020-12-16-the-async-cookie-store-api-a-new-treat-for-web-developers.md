---
layout: post
title: "비동기 Cookie Store API: 웹 개발자를 위한 새로운 기술"
author: 'Code Tower'
thumbnail: https://blog.logrocket.com/wp-content/uploads/2020/12/async-cookie-store-api.png
tags: undefined
---


![image](https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2020/12/async-cookie-store-api.png?fit=730%2C487&ssl=1)

## 배경

쿠키는 브라우저에 정보를 저장하는 가장 오래된 방법 중 하나입니다. 상태 비저장 HTTP 프로토콜을 위한 상태 저장 또는 세션 정보를 저장하기 위한 신뢰할 수 있는 메커니즘으로 설계되었다. 이러한 종류의 정보는 일반적으로 인증된 사용자의 검색 활동 또는 사용자가 방문한 페이지 또는 클릭한 링크와 같은 동작으로 구성됩니다.

간단히 말해, 서버는 HTTP 요청을 받은 후 응답과 함께 하나 이상의 `Set-Cookie` 헤더를 클라이언트에 다시 보낼 수 있습니다. 쿠키는 보통 이 클라이언트가 저장한 후 `쿠키` HTTP 헤더 내에서 동일한 서버로 요청을 전송하면 된다. 따라서 쿠키가 동일한 브라우저 클라이언트 세션에서 요청이 왔는지 여부를 확인하는 데 사용됩니다.

## 쿠키의 문제

쿠키가 중요한 사용 사례를 해결하는 동안, 그들은 많은 문제를 제기했습니다. DOM의 일부인 `document.cookie`에 쿠키를 모두 저장하는 것은 문제가 있었기 때문에 이들의 인터페이스는 상당히 복잡했다. 쓰기 수행의 결과를 말할 방법이 없었다. 문서 스크립트는 읽기 또는 가져오기 요청을 실행하여 이전 쓰기 또는 만들기 요청의 결과를 확인해야 합니다.

또 다른 문제는 쿠키의 속성을 읽어도 구문 분석/시리얼라이제이션이 필요하다는 것이다. 이는 각 쿠키의 이름-값 쌍이 쌍 목록으로 연결되고 각 목록 항목이 세미콜론으로 구분된 단일 문자열로 반환되기 때문입니다.

일반적으로 쿠키를 관리하거나 쿠키 가져오기, 쿠키 존재 여부 확인, 쿠키 데이터에 특정 값의 존재 여부 확인 등과 같은 작업을 수행할 때 또 다른 문제가 발생했습니다.

오늘날 개발자들은 Indexed와 같은 최신 스토리지 API를 사용할 것을 강력히 권장합니다.브라우저에 세션 데이터를 저장하는 DB 또는 `localStorage`입니다. 이것은 쿠키보다 저장 제한이 더 크고 클라이언트의 쿠키 정보가 서버로 전송되지 않기 때문입니다.

그러나 프로젝트에 여전히 쿠키를 사용하는 강력한 사례가 있다면 운이 좋은 것입니다. 비동기 Cookie Store API는 새롭고 향상된 작업 방식을 제공합니다.

## 쿠키 작동 방식: 웹 쿠키 동작에 대한 프라이머

여기서 우리는 새로운 비동기 API의 유용성을 인식하기 시작할 수 있도록 쿠키와 관련된 동작과 복잡성에 대해 탐구할 것이다.

오늘날 쿠키는 널리 사용되고 있지만, 쿠키의 인터페이스는 복잡성과 성능 문제의 원인이 되어 왔습니다. document.cookie 속성을 사용하면 문서와 관련된 쿠키를 읽고 쓸 수 있습니다. 이 문서는 쿠키의 실제 값에 대한 수집 및 설정자 역할을 합니다.

하지만, 우리가 `document.cookie` getter를 사용할 때마다 브라우저는 우리가 요청한 쿠키 정보를 얻을 때까지 자바스크립트 실행을 중단해야 합니다. 물론 이로 인해 UI/UX에 문제가 발생할 수 있습니다. 아래 쿠키 읽기 및 쓰기 작업에 대해 알아보면 더 좋은 느낌을 받을 수 있습니다.

### 쿠키 가져오기

특정한 쿠키 값을 얻는 것은 항상 매우 어려운 일로 여겨졌다. 모든 쿠키를 포함하는 전체 문자열인 document.cookie 값을 반복하는 옵션이 있었습니다. 특정 이름의 쿠키 값에 액세스하는 예를 살펴보겠습니다.

```js
document.cookie = "name1=value1";
document.cookie = "name2=value2";
document.cookie = "name3=value3";

// to get a cookie value with name value2
const cookieValue = document.cookie
  .split('; ')
  .find(row => row.startsWith('name2'))
  .split('=')[1];

console.log(cookieValue) // value2
```

이 영구 스택 오버플로 스레드를 통해 보다 일반적인 방법은 다음과 같습니다.

```js
const getCookie = (name) => {
  return document.cookie.split('; ').reduce((r, v) => {
    const parts = v.split('=')
    return parts[0] === name ? decodeURIComponent(parts[1]) : r
  }, '')
}
```

### 쿠키 설정

쿠키 값을 설정하는 API는 매우 구식인 것 같습니다. 그 이유는 무엇입니까? 글쎄요, 쿠키 데이터를 설정한 후, 쿠키가 성공적으로 생성되었다는 것을 알 수 있는 방법이 없습니다.

위의 것과 같은 getCookie 함수를 사용하여 쿠키 문자열 위로 루프하여 쿠키 데이터에 대해 설정한 값을 찾는 것이 해결 방법입니다.

```coffeescript
document.cookie = "name=value";
```

쿠키를 설정할 때 또 다른 문제는 쿠키 저장소 오류를 보고하는 잘 정의된 메커니즘이 없다는 것입니다. 이는 물론 document.cookie가 동기화되기 때문이다.

## 비동기 Cookie Store API 소개

document.cookie에서 쿠키를 얻는 이상한 방법에 싫증이 났나? 설정한 쿠키가 실제로 생성되었는지 확실하지 않습니까? 이 절에서는 이러한 문제를 다룹니다.

새로운 쿠키스토어 API는 `document.cookie`의 비동기식 대안을 제공하고 이러한 쿠키를 서비스 근로자들에게 노출시킴으로써 쿠키와 관련된 모든 단점을 개선하는 것을 목표로 하고 있다. API는 쿠키 관리를 위한 강력하고 논리적인 방법을 제공합니다. 요약하자면, API를 통해 보다 쉽게 다음과 같은 작업을 수행할 수 있습니다.

- 비동기식으로 쿠키에 액세스하여 주 스레드에서 너무 많은 작업 방지
- 이제 쿠키 변경 사항을 관찰하거나 모니터링할 수 있으므로 쿠키 폴링 방지
- 서비스 직원의 쿠키 액세스

> 참고: 'document.cookie' API의 동기식 설계로 인해 이전에는 쿠키가 서비스 작업자의 범위에 접근할 수 없었습니다.

서비스 근로자는 일종의 HTTP 프록시 역할을 하기 때문에 자신의 범위 내에서 페이지에 액세스할 수 있는 쿠키를 읽고 수정할 수 있어야 합니다. 또한 세션 상태의 변화에 신속하게 대응해야 하므로 오래된 캐시 데이터나 오래된 캐시 데이터를 정리하는 데 도움이 됩니다.

새 쿠키 저장소 API에는 문서 및 서비스 작업자의 쿠키 변경(폴링 대신)을 관찰하는 방법이 포함되어 있습니다. 쿠키 변경을 관찰하는 방법에는 쿠키가 값을 변경할 때 서비스 작업자를 활성화하는 기능이 있습니다.

## 지금 비동기 쿠키 저장소 사용

오늘 Cookie Store API를 사용하려면 오리진 평가판 플래그를 사용하도록 설정할 수 있습니다. 다만 작성 당시에는 API가 현재 커뮤니티 피드백을 기반으로 대대적인 개선을 진행 중이어서 오리진 평가판 플래그가 닫혀 있다. 원심 재판은 정비·개선이 완료된 뒤 다시 열릴 것으로 보인다. 자세한 내용은 여기에서 확인할 수 있습니다.

이렇게 하면 로컬에서 계속 사용해 볼 수 있습니다. 즉, CLI에서 API를 사용하도록 설정할 수 있습니다. 이 API는 현재 세션에 대해 Chrome에서 전체적으로 사용할 수 있습니다. 아래 명령을 참조하십시오.

```bash
chrome --enable-blink-features=CookieStore
```

또는 "chrome://flags"에서 "#enable-실험-웹 플랫폼-features" 플래그를 활성화할 수 있다.

### 쿠키 저장소 API를 사용하여 쿠키 쿼리, 수정 및 모니터링 소개

#### 쿠키 쿼리/읽기

문서 창과 서비스 작업자 모두 글로벌 개체의 쿠키스토어 속성을 통해 동일한 쿼리 API에 액세스합니다. 쿠키스토어의 get() 및 get All() 방법은 쿠키를 쿼리하는 데 사용됩니다. 이것은 우리가 오류를 쉽게 확인할 수 있는 약속을 반환한다는 것을 잊지 마세요.

이들은 다음과 같은 주장을 취합니다.

- 이름
- 옵션 목록(`getAll`()의 경우 선택 사항)

get() 방법은 기본적으로 첫 번째 결과만 반환하는 getAll()의 한 형태다. 예는 다음과 같습니다.

```js
try {
    const cookie = await cookieStore.get('session_id');
    if (cookie) {
    console.log(`Found ${cookie.name} cookie: ${cookie.value}`);
} else {
    console.log('Cookie not found');
}
} catch (error) {
  console.error(`Cookie store error: ${error}`);
}
```

get() 및 getAll()에서 반환되는 개체는 이전 document.cookie API에서와 같이 이름과 값뿐만 아니라 쿠키 저장소의 모든 관련 정보를 포함합니다.

#### 쿠키 수정/쓰기

또한 문서와 서비스 작업자 모두 글로벌 개체의 쿠키스토어 속성을 통해 동일한 수정 API에 액세스합니다. 쿠키는 set() 메서드를 사용하여 생성 또는 수정(쓰기)됩니다.

```js
try {
    await cookieStore.set('opted_out', '1');
} catch (error) {
    console.error(`Failed to set cookie: ${error}`);
}
```

cookieStore.set가 반환한 약속이 해결된 후에만 변경 사항이 적용된다는 점을 명심해야 한다.

#### 쿠키 삭제

쿠키는 삭제() 방법을 사용하여 삭제(만료)됩니다.

```coffeescript
try {
  await cookieStore.delete('session_id');
} catch (error) {
  console.error(`Failed to delete cookie: ${error}`);
}
```

후드 아래에서 쿠키의 만료 날짜를 과거로 변경하면 쿠키 삭제가 수행되지만 여전히 작동합니다.

#### 쿠키 모니터링

쿠키 저장소 API는 폴링이 필요하지 않은 쿠키 변경 사항을 관찰하기 위한 대체 방법을 제공합니다. JavaScript에서 쿠키에 액세스하는 인기 있는 응용 프로그램은 사용자가 로그아웃할 때 이를 탐지하고 그에 따라 UI를 업데이트하는 것입니다.

모든 관련 쿠키 변경에 대해 변경 이벤트가 실행됩니다. 다음은 `변경` 이벤트에 등록하는 간단한 예입니다.

```js
cookieStore.addEventListener('change', event => {
    console.log(`${event.changed.length} changed cookies`);
 for (const cookie in event.changed)
    console.log(`Cookie ${cookie.name} changed to ${cookie.value}`);
  for (const cookie in event.deleted)
    console.log(`Cookie ${cookie.name} deleted`);
});
```

또한 이 API는 브라우저가 성능상의 이유로 변경 이벤트를 일괄 처리할 수 있도록 설계되었습니다. 자세한 내용은 여기에서 확인할 수 있습니다.

#### 서비스 직원에 대한 확장

쿠키 액세스가 필요한 서비스 근로자는 동기식(synchronic)에 의존할 수 없어 document.cookie 인터페이스를 차단합니다. 이는 서비스 근로자가 이벤트 루프를 차단할 수 없어 다른 이벤트 처리에 지장을 주기 때문이다.

그러나 Cookie Store API는 비동기적이므로 서비스 작업자에게 허용됩니다. 서비스 작업자는 쿠키 액세스가 필요한 경우가 있습니다(예:

- 만료되지 않은 세션에서 사용자 인증을 나타내는 쿠키가 있는 동안에만 개인 데이터가 표시되거나 전송되도록 하려면
- 세션 쿠키 변경 후 한 사용자 계정에 대한 데이터가 실수로 표시되지 않도록 하려면

쿠키와 상호 작용은 문서 컨텍스트와 서비스 작업자 모두에서 동일한 방식으로 작동합니다. 하지만, 쿠키 변화를 관찰하는 것은 서비스 직종에서 조금 다릅니다. 이는 서비스 근로자를 깨우는 데 상당한 비용이 들 수 있기 때문에, 근로자가 관심을 갖는 쿠키 변화에 대한 명확한 설명이 필요하기 때문이다.

자세한 내용은 여기 초안 문서에서 확인할 수 있습니다. 또한 설명서에서 서비스 종사자의 변경 이벤트에 대한 섹션을 참조할 수 있습니다.

## 결론

이 흥미로운 제안은 설정, 삭제 및 읽기 작업의 문서 이벤트에 대한 비동기 쿠키 API를 제공합니다. 아마도 가장 중요한 것은 서비스 근로자가 쿠키를 읽을 수 있게 해 줄 것이라는 점입니다. 현재 문서에서 쿠키를 읽고 쓰는 작업은 동기식 프로세스이기 때문에 페이지 로딩 시간이 느리고 성가시게 됩니다. 쿠키에 대한 비동기식 액세스는 이러한 요구를 해결합니다.

이 API에는 서비스 근로자를 깨우는 쿠키 체인지 이벤트가 포함되어 있다. 서비스 작업자의 쿠키 변경 이벤트는 글로벌 범위에서 발생하지만 서비스 작업자 등록과 관련된 명시적 구독이 필요합니다. 자세한 내용은 여기를 참조하십시오.

또한 API에는 쿠키 저장소 오류를 보고하기 위한 명확한 메커니즘이 있습니다. 또한 알려진 크로스 브라우저 비호환성 및 사양과 브라우저 동작 간의 차이점 중 일부를 해결합니다.

현재 브라우저는 모든 HTTP 요청에 쿠키의 스냅샷을 포함해야 하므로 저장소 및 네트워크 스택에 쿠키 변경 사항이 전파됩니다. 최신 브라우저는 고도로 최적화된 쿠키 저장소 구현 기능을 갖추고 있지만, 네트워크 스택에 연결할 필요가 없는 다른 저장 메커니즘만큼 효율적인 쿠키를 만들 수는 없습니다. 그러나 이 제안은 일반적으로 쿠키의 네트워크 계층 또는 보안 모델에서의 쿠키 처리 방법을 변경하는 것을 목표로 하지 않는다.

쿠키스토어 API에 대한 자세한 내용은 제안서/초안, 설명자 자료, GitHubrepo를 참조하시면 됩니다. 쿠키 변경 이벤트에 대한 자세한 내용은 여기에서 확인할 수 있습니다. 또한 이 제안을 브라우저 쿠키를 처리하기 위한 단순하고 가벼운 자바스크립트 API인 대체 구현과 비교할 수도 있습니다.