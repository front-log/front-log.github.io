---
layout: post
title: "녹 특성: 깊이 잠수하다."
author: "Front Log"
thumbnail: "https://blog.logrocket.com/wp-content/uploads/2020/11/rust-traits-deep-dive.png"
tags: 
---


![image](https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2020/11/rust-traits-deep-dive.png?fit=730%2C487&ssl=1)

러스트를 배울 때, 여러분은 조만간 특성 개념에 부딪힐 가능성이 높습니다.

특성은 여러 유형에 걸쳐 동작을 공유할 수 있도록 하며 코드 재사용을 용이하게 합니다. 또한 유형이 특성 형태로 필요한 동작을 구현하는 한, 그들은 우리가 그들의 주장을 위해 다른 유형을 받아들이는 함수를 쓸 수 있게 한다.

이 튜토리얼에서는 Rust의 기본 특성에 대해 살펴보고 가장 자주 접할 수 있는 몇 가지 문제에 대해 살펴봅니다.

## 러스트의 특징은 무엇인가?

특성은 Rust에서 공유 동작을 정의하는 방법입니다. 예를 들어 Rust by President:

> "trit"는 알 수 없는 유형인 "Self"에 대해 정의된 메서드의 모음입니다. 동일한 특성으로 선언된 다른 방법에 액세스할 수 있습니다.

필요한 행동을 하는 모든 유형에 적용할 수 있는 기능을 정의하고자 할 때, 우리는 특성을 사용합니다.

## 녹의 특성

먼저, 우리가 그것들을 어떻게 정의하고 구현하는지, 어떤 용어와 통사적 설탕, 그리고 어떤 특성에 대해 어떤 종류의 방법을 정의할 수 있는지 등 몇 가지 특성 기본을 살펴봅시다.

### Rust에서 특성 정의

특성을 정의하려면 `특징` 키워드를 사용합니다.

```php
trait WithName {
    fn new(name: String) -> Self;

    fn get_name(&self) -> &str;

    fn print(&self) {
    println!("My name is {}", self.get_name())
    }
}
```

특성은 공유 동작을 정의하는 방법이기 때문에, 우리는 정의하는 특성에 속하는 방법을 정의할 수 있습니다. 대부분의 특성이 행동을 공유하기 위해 존재하지만, 러스트는 또한 표식 특성이라고 불리는 것을 가지고 있다. 마커 특성은 어떠한 동작도 가지고 있지 않지만 컴파일러에게 확실한 보증을 제공하는 데 사용됩니다. Rust 문서에서 `std::marker` 모듈에 대한 자세한 내용을 볼 수 있습니다.

위의 특성 정의에는 모두 약간 다르게 동작하는 세 가지 방법이 있습니다. 잠시 뒤 자세히 살펴보겠지만 우선 `셀프`와 `셀프`의 사용법을 살펴보자.

### 'Self'와 'Self'는 무엇인가?

특성 정의(위 내용 포함)에서 우리는 `Self`라는 특수 유형에 접근할 수 있다. `Self`는 유형 정의, 특성 정의 및 (Rust 설명서에 따르면) `impl` 블록 내에서만 사용할 수 있는 특수 키워드이다.

특성 정의에서 구현 유형을 나타냅니다. 다시 말해 구조 A를 선언하고 이를 위해 위드 네임(With Name) 특성을 구현한다면 새로운 방식으로 반환되는 셀프 타입은 A가 될 것이다. 구조체 B의 경우 유형은 B가 됩니다.

더

### 방법: 인스턴스, 정적 컨텍스트 및 기본 구현

왜냐하면 `

WithName 특성의 print와 같은 메소드에도 기본 구현이 있을 수 있습니다. 이렇게 하면 특성을 구현할 때 이 방법을 선택적으로 구현할 수 있습니다. 재정의되지 않으면 기본 구현이 사용됩니다.

### Rust에서 특성 구현

특성을 구현하려면 특성을 구현할 유형에 대해 `임플` 블록을 선언합니다. 구문이 <type에 대한 `impl <trit`입니다. 기본 구현이 없는 모든 방법을 구현해야 합니다.

예를 들어, 구조체 이름(String)에 대해 `WithName` 특성을 구현하려면 다음과 같이 수행할 수 있습니다.

```php
trait WithName {
    fn new(name: String) -> Self;

    fn get_name(&self) -> &str;

    fn print(&self) {
    println!("My name is {}", self.get_name())
    }
}

struct Name(String);

impl WithName for Name {
    fn new(name: String) -> Self {
    Name(name)
    }

    fn get_name(&self) -> &str {
    &self.0
    }
}
```

구현이 완료되지 않은 경우 신뢰할 수 있는 컴파일러 친구가 알려 줍니다.

### 외부 상자에서 특성 가져오기

외부 상자에서 특성을 가져오려면 정규 `사용` 문을 사용하십시오. 예를 들어 Rust의 인기 있는 직렬화/비직렬화 상자인 Serde에서 `Serialize(시리얼라이즈)` 특성을 가져오려면 다음과 같이 하면 됩니다.

```php
use serde::Serialize;

struct A;

impl Serialize for A {
    fn serialize<S>(
    &self,
    _: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
    S: serde::Serializer,
    {
    todo!()
    }
}
```

## 녹에서 특성을 사용하는 방법

특성을 정의하고 구현하는 방법에 대해 살펴본 후, 실제로 특성을 사용하는 방법에 대해 살펴보겠습니다.

### 함수 인수의 특성 및 특성 한계

우리는 함수를 함수 매개 변수로 사용하여 함수에서 x를 수행할 수 있는 모든 유형을 수용할 수 있다. 여기서 x는 특성에 의해 정의된 일부 동작이다. 또한 특성 한계를 사용하여 특정 특성을 구현하는 모든 유형 `T`를 허용한다고 말하는 등 제네릭을 세분화하고 제한할 수 있다.

얼핏 보면 이 두 가지 특성을 사용하는 방법이 같은 것을 성취하는 것처럼 들릴 수도 있지만 미묘한 차이가 있다. 매개 변수가 여러 개 있는 경우 특성 한계를 사용하여 매개 변수가 동일한 유형인지 확인할 수 있습니다.

다음 두 가지 기능을 고려하십시오.

```cpp
use std::fmt::Debug;

fn f(a: &Debug, b: &Debug) {
    todo!()
}

fn g<T: Debug>(a: &T, b: &T) {
    todo!()
}
```

아무 것도 하지 않는다는 사실을 무시한 f 함수는 디버그 특성을 구현하는 두 가지 주장을 서로 다른 유형이라도 그대로 받아들인다. 반면, g는 같은 유형의 두 인수만 허용하지만, 그 유형은 디버그를 구현하는 모든 유형이 될 수 있다.

다시 말해서, g에 대한 인수는 같은 유형이어야 하는 반면, f에 대한 인수는 같은 유형일 수 있지만 두 가지 유형일 수도 있다.

### 귀환 특성

우리는 기능을 통해 특성을 반환 유형으로 사용할 수 있습니다. 이를 위한 두 가지 다른 방법이 있다. 즉, `impl Attribute`와 `Box<dyn Attribute. 다시 말하지만, 차이는 미묘하지만 중요하다.

```java
use std::fmt::Debug;

fn dyn_trait(n: u8) -> Box<dyn Debug> {
    todo!()
}

fn impl_trait(n: u8) -> impl Debug {
    todo!()
}
```

dyn_tratit 함수는 디버그 특성을 구현하는 모든 유형을 반환할 수 있으며 입력 인수에 따라 다른 유형도 반환할 수 있다. 이것은 특성 개체로 알려져 있습니다. "Rust Programming Language" 책에는 특성 객체를 사용하여 동적 전송을 수행하는 섹션이 있습니다.

반면 impl_trit 방식은 디버그 특성을 구현하는 단일 유형만 반환할 수 있다. 즉, 함수는 항상 동일한 유형을 반환합니다.

이러한 차이로 인해 "impl Attribute"가 특성 객체보다 덜 유용해 보일 수 있지만, 매우 중요한 기능(타자 및 작업 용이성 외에도)을 사용하여 반복기와 닫힘을 반환할 수 있습니다. 이것은 이 책의 특징에 관한 챕터인 "특징을 구현하는 유형들"에서 더 자세히 설명된다.

### 특성 콤보

여러 가지 특성을 함께 사용할 수 있습니다. 이것이 특성 콤보라고 알려진 것입니다. 이를 위해 T: 특성 1 + 특성 2 + 특성 3의 특성을 `추가`합니다.

글을 쓸 때, 안정적인 러스트에 다른 이름으로 특정한 특징 조합을 언급할 방법이 없습니다. 그러나 특성 별칭으로 알려진 이 기능은 야간 채널에서 사용할 수 있습니다. GitHub에서 추적 문제를 확인해 보세요.

### 초특허

Rust는 특성이 다른 특성의 확장이라는 것을 명시하는 방법을 가지고 있으며, 우리에게 다른 언어의 하위 분류와 유사한 것을 제공한다.

하위 특성을 작성하려면 다음과 같은 유형으로 수퍼 특성을 구현함을 지정합니다.

```cpp
trait MyDebug : std::fmt::Debug {
    fn my_subtrait_function(&self);
}
```

이 새로운 하위 특성을 구현하려면 하위 특성에서 필요한 모든 방법과 하위 특성에서 필요한 모든 방법을 구현해야 합니다.

### 관련 유형

특성을 다룰 때, 연관된 유형은 꽤 자주 나타나는 용어입니다. 대표적인 예로 `반복기` 특성이 있는데, 여기서 `다음` 함수의 반환 유형을 나타내는 데 사용된다. 이들은 제네릭(또는 유형 매개 변수)과 많은 유사성을 공유하지만 몇 가지 주요 차이점이 있습니다.

간단히 말해서, 제네릭은 연관된 유형이 할 수 있는 모든 것을 할 수 있다. 그러나 관련 유형을 사용하면 구현 유형이 이 특성의 단일 구현으로만 제한된다. 이는 반복자(Iterator)와 데레프(Deref) 특성 등 여러 상황에서 유용하다.

연관된 유형에 대해 자세히 알아보려면 "관련된 유형으로 특성 정의에서 자리 표시자 유형 지정" 섹션을 참조하십시오.

### 특성 상수

특성은 연관된 상수도 가질 수 있습니다. 이것은 특성 방법보다 덜 일반적이지만, 그 용도가 없는 것은 아니다. 메소드와 마찬가지로 상수도 기본값을 제공할 수 있습니다.

```undefined
trait ConstTrait {
    const GREETING: &'static str;
    const NUMBER: i32 = 42;
}
```

### #[#]

일부 특성은 자동으로 파생될 수 있으며, 이는 컴파일러가 이러한 특성을 구현할 수 있음을 의미합니다. Rust by 예제에서는 이 작업을 수행하는 방법과 작동 방법에 대해 잘 설명합니다. 이는 일반적으로 std::fmt::Debug(드라이브(디버그)) 특성에서 볼 수 있다.

특성을 도출하는 것은 직접 작업을 하지 않고도 여러분의 유형에 맞는 추가적인 기능을 얻을 수 있는 좋은 방법입니다.

### 고아원 규칙

특성을 사용할 때 다른 외부 상자의 유형에 대해 외부 상자에서 특성을 구현하려는 경우가 발생할 수 있습니다. 고아 규칙 때문에 작동하지 않습니다. 특성 또는 유형을 소유하지 않으면 유형에 대한 특성을 구현할 수 없습니다. 하지만 둘 중 하나를 소유하고 있다면, 할 수 있다.

책에 따르면

> [이] 규칙이 없으면 두 개의 상자가 동일한 유형에 대해 동일한 특성을 구현할 수 있으며, Rust는 어떤 구현을 사용해야 할지 알 수 없습니다.

이 제한을 해결해야 하는 경우 새 유형 패턴을 사용할 수 있습니다.

## 추가 읽기

특성은 러스트의 중요한 부분이기 때문에 다루어야 할 많은 근거가 있습니다. 이 튜토리얼에서 특성이 무엇인지, 특성이 어떻게 작동하는지, 고급 사용 사례에 접근하는 방법을 이해하셨기를 바랍니다.

이 주제들에 대해 스스로 더 자세히 알고 싶다면 본문 전체에 흩어져 있는 참고 문헌들을 살펴보길 권한다. 이 가이드를 읽고 더 깊이 잠수하고 싶다면 `녹스 프로그래밍 언어`의 특성과 고급 특성에 관한 장, 그리고 `녹스 바이 예`의 특징에 관한 장을 살펴보는 것을 추천한다.