---
layout: post
title: "캐시란 무엇인가?"
author: "Front Log"
thumbnail: "https://blog.logrocket.com/wp-content/uploads/2020/10/whatisacache-nocdn.png"
tags: 
---


![image](https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2020/10/whatisacache-nocdn.png?fit=730%2C412&ssl=1)

캐쉬가 무엇인지 잘 모르시겠지만, 캐쉬를 정말 이해하고 싶으십니까? 캐슁을 사용하여 애플리케이션을 더 빠르고, 더 탄력적이며, 더 적은 리소스로 고객에게 제공할 수 있는 방법을 알고 싶으십니까? 그럼 이 물건은 당신을 위한 것입니다.

이 기사에서는 캐시가 무엇인지, 그리고 대부분의 프런트 엔드 개발자들에게 어떤 종류의 캐슁이 적절한지 살펴보겠습니다. 서비스 직원, 브라우저 자체 및 CDN 및 백엔드 같은 외부 캐쉬를 통해 JavaScript에서 데이터를 캐슁할 수 있는 방법에 대해 살펴보겠습니다. 마지막으로, 캐시 무효화를 살펴보고, 캐시 무효화가 무엇인지, 그리고 왜 그렇게 제대로 처리하기가 어려운지를 모두 기본적으로 이해하도록 하겠습니다.

## 캐시란 무엇인가? 🤔

캐슁을 구현할 수 있는 여러 가지 방법을 살펴보기 전에 캐시가 무엇인지에 대한 기술적 정의를 살펴봐야 합니다. 간단히 말해, 캐시는 이전에 받은 데이터를 저장하여 나중에 다시 검색하기 쉽게 하는 방법입니다. 예를 들어 설명하겠습니다.

대부분의 인터넷 사용자와 마찬가지로 특정 시점에 컴퓨터에 파일을 다운로드했을 수 있습니다. 아마 이건 당신이 학교에서 친구 몇 명과 함께 작업하고 있는 문서일 거예요. 이제 컴퓨터에 저장되었으므로 작업할 때마다 새 사본을 가져오지 않고 언제든지 액세스할 수 있습니다. 이 기능 – 일부 리소스에 더 쉽고 저렴하게 액세스할 수 있는 것이 캐쉬의 주요 아이디어입니다.

현대 기술 스택의 대부분 부분에서 이러한 기술이 사용되는 것을 볼 수 있습니다. 우리는 우리의 브라우저에 사진을 캐슁하여 후속 방문 시 사진을 바로 표시합니다. 사용자 JSON 개체를 상태 관리 라이브러리에서 캐시하므로 표시된 내용을 변경할 때마다 서버에 사용자 이름을 묻지 않아도 됩니다. 우리는 심지어 전체 웹 앱을 브라우저에 캐슁하여 인터넷 연결(일명 PWA) 없이 작동하도록 합니다.

## 그럼 왜 영원히 모든 걸 캐슁하지 않는 거죠?

이러한 모든 상황을 고려해 볼 때, 왜 우리가 모든 것을 영원히 캐시하지 않는지 자문해 볼 수 있습니다! 이미 로컬에 새 데이터가 있는데 왜 굳이 새 데이터를 가져올까요? 알고 보니 세상은 정적이 아닙니다. 그리고 우리가 다운로드 하는 데이터는 미래에 변할 가능성이 있습니다. 따라서 캐시할 때마다 오래된 정보를 처리할 위험이 있습니다.

캐슁할 내용과 캐슁 기간을 파악하는 것은 각 정보의 활용 사례와 변경사항을 즉시 반영하는 것이 얼마나 중요한지를 고려해야 하는 문제 중 하나입니다. 그래서 저는 항상 그것을 바로 잡기 위한 예술이라고 생각해왔습니다. 이에 대해 몇 가지 예를 살펴보고 이 글의 뒷부분에서 몇 가지 실제적인 힌트를 드리겠습니다.

## 다양한 캐시 유형

프런트 엔드 개발자는 스택을 진행하면서 여러 가지 캐시 유형을 볼 수 있습니다. 다음은 캐쉬의 각 "레이어"와 캐쉬가 빛을 발하는 시기에 대한 설명입니다.

### JavaScript 캐시

코드에서 가장 먼저 발생하는 캐시는 일반적으로 직접 만드는 캐시입니다. 즉, API의 데이터를 메모리에 저장하는 일종의 방법입니다.

무효화 없이 단순 캐쉬를 매우 간단하게 구현하면 다음과 같은 이점이 있습니다(여유, 나중에 다시 설명하겠습니다).

```js
let cache = {};
async function getCachedValue(key, callback) {
  if (cache.hasOwnProperty(key)) {
    return cache[key];
  }
  const result = await callback();
  cache[key] = result;
  return result;
}
```

여기에는 이 캐싱 함수에 대한 호출 간에 유지되는 "글로벌" 캐시 개체가 있습니다. 캐시에 캐시 키가 포함되어 있는지 확인하고, 포함되어 있으면 캐시된 값을 반환하기만 하면 됩니다. 그렇지 않으면 제공된 콜백 함수를 호출하여 값을 얻은 다음 캐시에 저장했다가 사용자에게 반환합니다.

그런 다음 키를 사용하여 이 함수를 호출하고 해당 데이터를 비동기식으로 가져올 콜백을 호출합니다.

```undefined
const user = getCachedValue("user", async () => {
  const res = await fetch("/api/user");
  return res.json();
});
```

여기서 이 코드가 처음 호출될 때 사용자를 가져옵니다. 두 번째로, 우리는 캐시에서 사용자를 찾았을 것이고, 서버에 대한 추가 호출을 피했을 것이다.

이것을 돕는 수많은 도서관들이 있다. 저는 주로 리액트 코드를 직접 작성합니다. 이러한 에코시스템에서 SWR과 리액트 쿼리는 이러한 캐시를 구현하는 두 가지 훌륭한 주장입니다(필요한 다른 여러 가지 기능 외에도).

### HTTP 캐시

캐싱은 웹 브라우저의 가장 기본적인 기능 중 하나이며 수십 년 동안 그래왔다. 이것이 바로 HTTP라는 서버에서 사용자로 데이터를 전송하는 프로토콜에 내장된 이유입니다. 서버는 각 응답에 추가된 특수 헤더 필드를 통해 브라우저에 특정 기간 동안 특정 파일을 캐시하도록 지시할 수 있습니다. 특히, 이것은 당신이 읽고자 하는 `캐시 컨트롤` 헤더이다.

이 캐싱 메커니즘은 대부분의 사용자가 캐싱 소리를 들을 때 생각하는 것입니다. 여러분은 "캐시 지우기"라는 말을 웹 사이트의 이상한 버그를 해결하기 위한 방법으로 들어본 적이 있을 것입니다. 이것이 그들이 언급한 캐시입니다.

HTTP를 통해 리소스를 캐슁하는 것은 사이트를 개선하는 놀라운 툴입니다. 올바른 캐시 헤더를 추가하고 모든 정적 리소스에 대해 고유한 파일 이름을 생성하면 모든 리소스를 클라이언트 측에서 무기한 캐슁할 수 있습니다(즉, 다른 사용자가 사용자에게 캐쉬를 지우라고 지시할 때까지). 동적 컨텐츠도 신중하게 처리하면 캐시할 수 있습니다.

HTTP 캐싱 기법에 대해 깊이 파고들고 싶지만 MDN의 이 문제에 대한 리소스가 너무 포괄적이어서 대신 권장하지 않는다. 여기서 확인해 보세요.

### 서비스 작업자 캐시

경우에 따라서는 JavaScript의 프로그래밍 가능성과 함께 HTTP 캐시의 성능이 필요합니다. 그곳이 소위 서비스직 종사자들의 손길이 닿는 곳입니다. 서비스 직원은 모든 리소스를 로컬에서 캐슁할 수 있지만 캐시 시점과 기간을 완벽하게 프로그래밍 방식으로 제어할 수 있도록 지원합니다.

서비스 근로자는 모든 네트워크 요청에 대한 중개자 역할을 합니다. 웹 응용 프로그램이 리소스를 요청하면(예: 이미지) 언제든지 백그라운드에서 업데이트된 버전을 가져오는 동안 리소스를 인터셉트하고 캐시된 버전(또는 예비 버전)을 찾아 반환할 수 있습니다.

서비스 직원은 간단한 매니페스트 파일과 결합되어 원래 방문 후 웹 사이트에 대한 완전한 오프라인 환경을 만들 수도 있습니다. 이는 데이터 범위가 생각보다 보편적이지 않은 세상에서 매우 가치 있는 기능입니다.

마지막으로 주의할 말을 덧붙이겠습니다. 서비스 직원은 매우 강력하기 때문에 가까운 미래에 웹 사이트를 망칠 가능성도 있습니다. 이 프로세스는 사이트의 나머지 부분과 별도의 프로세스로 실행되므로 한 버전과 다음 버전 사이에서 유지됩니다. 즉, 😅를 망치지 않도록 각별히 주의해야 합니다.

다행히도, 준비된 서비스 직원 캐시를 만드는 데 도움이 되는 도구가 있습니다. Google의 워크박스와 같은 도구를 빌드 파이프라인에 연결하고 이를 생성하도록 할 수 있습니다. 됐다!

### 백엔드 캐시

프런트 엔드 개발용 캐싱 퍼즐의 마지막 조각은 프런트 엔드와는 전혀 관계가 없다. 대신 응용 프로그램의 서버 측에서 발생하는 캐싱입니다.

하지만 백엔드에서도 캐슁이 필요한 이유는 무엇입니까? 서버는 일반적으로 가장 강력한 클라이언트보다 훨씬 더 많은 리소스와 네트워크 안정성을 가지고 있습니다. 그런데 왜 데이터를 캐슁할 필요가 있을까요? 자, 알고 보니 서버는 다른 서비스에도 데이터를 요청합니다.

예를 들어 데이터베이스 쿼리를 사용합니다. 수백만 개의 레코드 데이터베이스를 검색하여 특정 쿼리와 관련된 레코드를 찾는 데 몇 초가 걸릴 수 있습니다. 백엔드 엔지니어는 이 작업을 반복하는 대신 이러한 쿼리를 잠시 동안 캐시하도록 선택할 수 있습니다. 통제할 수 없는 다른 외부 서비스도 캐싱의 좋은 기회가 될 수 있습니다.

서버 쪽 캐싱에는 분산 캐시라는 개념이 포함되어 있어 일이 상당히 복잡합니다. 둘 이상의 서버를 실행 중이고 요청이 해당 서버 중 하나로 전달될 수 있으므로 공유 캐시가 있어야 합니다. 이는 헤이즐캐스트와 같은 도구로 설정하기가 쉬워졌지만 여전히 많은 이들에게 걸림돌이다.

이런 종류의 캐슁에 대해서는 자세히 설명하지 않겠습니다. 이 기사의 적용범위가 다소 벗어난 것 같습니다. 하지만 여기에도 배울 것이 많다는 것을 알아두세요!

## 캐시에서 항목 제거

때로는 더 이상 캐시되는 것을 원하지 않을 수도 있습니다. 여기에는 전형적으로 세 가지 타당한 이유가 있다. 변경되었거나, 너무 오래되었거나, 자주 사용하지 않을 수 있습니다.

### 거의 사용되지 않는 항목

자주 사용되지 않는 항목을 제거하는 것부터 시작해 보겠습니다. 거의 사용되지 않는 데이터를 캐슁하는 데 인색한 이유는 무엇입니까? 글쎄, 우주 때문이지. 간단히 말해, 캐슁은 데이터를 저장하는 한 가지 방법일 뿐이며, 일부 데이터는 메가바이트 단위로 볼 때 상당히 클 수 있습니다. 시스템 구성에 따라 이 중복 데이터 저장을 수행할 공간이 부족해질 수 있습니다. 그런 다음 유용성별로 캐시 항목의 순위를 매겨야 하며 캐시된 리소스가 얼마나 자주 사용되는지는 분명 유용성에 적합한 지표입니다. 따라서 캐시에 새 항목을 추가하려면 가장 적게 사용된 항목을 먼저 제거해야 합니다.

가장 유용하지 않은 항목을 결정하는 몇 가지 기법이 있습니다. 주어진 시간 간격 동안 가장 적게 검색되거나 가장 최근에 사용된 항목일 수 있습니다. 어떤 기술을 선택하느냐는 자신과 특정 요구 사항에 따라 결정됩니다.

### 이전 항목

데이터를 충분히 최신 상태로 유지하면서 캐시 크기를 확인하는 또 다른 방법은 캐시에 저장된 시간에 따라 캐시 항목을 제거하는 것입니다. 이미지가 거의 변경되지 않기 때문에 사용자 데이터보다 더 오래 이미지를 캐시할 수 있지만, 경우에 대비하여 새 버전의 이미지도 가져오는 것이 좋습니다.

캐시된 리소스가 요청되고 캐시된 항목이 만료된 경우 새 버전이 대신 가져오고 이전 항목이 꺼져서 캐시가 다시 새로 고쳐집니다.

### 캐시 무효화

캐시 무효화로 돌아가겠다고 했잖아 그래서 그게 정확히 뭐죠?

캐시 무효화는 캐시된 데이터의 하위 집합을 캐시에서 제거하는 기술입니다. 일반적으로 캐시에서 데이터를 업데이트하고 응용 프로그램에서 새 버전을 가져오려는 경우 이 작업을 수행합니다.

캐슁하는 위치에 따라 이 작업도 다양한 방식으로 수행할 수 있습니다. JavaScript와 같이 프로그래밍 방식으로 작업을 수행하는 경우 캐시 항목을 제거하고 백그라운드에서 새 항목을 요청할 수 있습니다.

## 요약

캐슁은 여러 가지가 있기 때문에 어렵습니다. 애플리케이션, HTTP, 서비스 직원을 통해, 백엔드 자체에서도 데이터를 캐슁할 수 있습니다. 많은 사람들에게 무엇을 해야 할지는 분명하지 않지만, 바라건대, 이것이 이 모든 것이 어떻게 작용하는지에 대한 일종의 생각을 갖게 해주었다. 마지막으로, 캐시에서 무엇인가를 제거하려는 이유와 이를 위한 다양한 방법을 살펴보았습니다.