---
layout: post
title: "Node.js ORM을 사용하면 안 되는 이유"
author: "Front Log"
thumbnail: "https://blog.logrocket.com/wp-content/uploads/2018/11/nodejs-orm.png"
tags: 
---


![image](https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2018/11/nodejs-orm.png?fit=730%2C487&ssl=1)

이 튜토리얼에서는 프로젝트에서 ORM(개체 관계 매핑)을 사용하지 않는 세 가지 이유를 설명합니다. 논의된 개념은 모든 언어와 플랫폼에 적용 가능하지만 코드 예는 Node.js-향의 JavaScript로 작성되며 npm 저장소에서 얻은 패키지를 고려하고 있다.

나는 이 게시물에 언급된 어떤 모듈도 거절할 생각이 없다. 그들 한 사람 한 사람에게 많은 힘든 일이 가해졌다. 그것들은 매일 많은 요청에 즐겁게 응답하는 전 세계의 생산 응용 프로그램들에 의해 사용된다. 또한 ORM을 사용하여 애플리케이션을 구축했지만 후회되는 것은 없습니다.

다음 사항에 대해 자세히 설명합니다.

- Node.js의 ORM이란?
Node.js와 함께 ORM 사용
ORM 및 Node.js: 추상화 계층
Node.js와 함께 Secretize 사용
ORM이 정말 필요한가요?
Node.js에서 쿼리 작성기 사용: 단점
- Node.js의 ORM이란?
- Node.js와 함께 ORM 사용
- ORM 및 Node.js: 추상화 계층
- Node.js와 함께 Secretize 사용
- ORM이 정말 필요한가요?
- Node.js에서 쿼리 작성기 사용: 단점

## Node.js의 ORM이란?

객체 관계 매핑은 객체와 관계형 데이터베이스 시스템 간의 매핑 프로세스이다. 서로 다른 데이터베이스 시스템이 다양한 방식으로 데이터에 액세스하며 ORM은 액세스한 소스 및 애플리케이션이 시간이 지남에 따라 변경되더라도 개체를 유지 관리할 수 있도록 지원합니다. ORM은 일반적으로 데이터베이스 간 데이터 마이그레이션을 간소화하기 위해 사용됩니다.

ORM을 Node.js와 함께 사용하면 안 되는 이유에 대해 알아보기 전에 몇 가지 이점을 나열해 보겠습니다. Node.js의 ORM을 올바르게 사용하면 다음을 수행할 수 있습니다.

- 중복 코드 방지
- 한 데이터베이스에서 다른 데이터베이스로 쉽게 전환
- 여러 테이블에 대한 쿼리(ORM은 객체 지향 쿼리 접근 방식을 SQL로 변환)
- 비즈니스 논리에 더 집중하고 인터페이스 작성에는 덜 집중

## Node.js와 함께 ORM 사용

ORM은 강력한 도구입니다. 이 게시물에서 검토할 ORM은 SQLite, Postgre와 같은 SQL 백엔드와 통신할 수 있습니다.SQL, MySQL 및 MSSQL. 이 게시물의 예는 Postgre를 활용할 것이다.SQL - 매우 강력한 오픈 소스 SQL 서버입니다. MongoDB가 지원하는 Mongoose ORM과 같이 NoSQL 백엔드와 통신할 수 있는 ORM이 있지만, 우리는 이 게시물에 있는 ORM은 고려하지 않을 것이다.

먼저 다음 명령을 실행하여 Postgre 인스턴스를 시작합니다.로컬 SQL입니다. 기본 Postgre에 대한 요청이 수행되도록 구성됩니다.`localhost:5432`의 SQL 포트가 컨테이너로 전달됩니다. 또한 파일을 홈 디렉토리의 디스크에 기록하여 후속 인스턴스(instance)에서 이미 생성된 데이터를 보존합니다.

이제 데이터베이스를 실행 중이므로 일부 테이블과 데이터를 데이터베이스에 추가해야 합니다. 이를 통해 데이터에 대해 쿼리하고 다양한 추상화 계층을 더 잘 이해할 수 있다. 다음 명령을 실행하여 대화형 Postgre를 시작합니다.SQL 프롬프트:

프롬프트에서 이전 코드 블록의 암호를 "hunter12"로 입력합니다. 이제 연결되었으므로 다음 쿼리를 복사하여 프롬프트에 붙여넣고 Enter 키를 누릅니다.

이제 채워진 데이터베이스가 있습니다. psql 클라이언트와의 연결을 끊고 터미널을 다시 제어할 수 있도록 "종료"를 입력할 수 있습니다. 원시 SQL 명령을 다시 실행하려면 동일한 `docker run` 명령을 다시 실행할 수 있습니다.

마지막으로 다음 JSON 구조를 포함하는 `connection.json` 파일도 생성해야 합니다. 나중에 노드 응용 프로그램에서 데이터베이스에 연결하는 데 사용됩니다.

```undefined
{
  "host": "localhost",
  "port": 5432,
  "database": "orm-db",
  "user": "orm-user",
  "password": "hunter12"
}
```

## ORM 및 Node.js: 추상화 계층

너무 많은 코드에 뛰어들기 전에 추상화의 몇 가지 다른 레이어를 명확히 해 봅시다. 컴퓨터 과학의 모든 것과 마찬가지로, 추상화의 층을 더하면 절충이 일어난다. 각각의 추가된 추상화 계층으로 우리는 성능 저하를 개발자 생산성의 증가와 교환하려고 시도한다(이것이 항상 그런 것은 아니지만).

### 로우 레벨: 데이터베이스 드라이버

이는 기본적으로 TCP 패킷을 수동으로 생성하여 데이터베이스로 전송하는 데 부족한 수준입니다. 데이터베이스 드라이버가 데이터베이스 연결(및 연결 풀링)을 처리합니다. 이 수준에서는 원시 SQL 문자열을 작성하여 데이터베이스로 전송하고 데이터베이스로부터 응답을 수신합니다. Node.js 생태계에는 이 계층에서 운영되는 많은 라이브러리가 있다. 다음은 세 가지 인기 있는 라이브러리입니다.

- mysql: MySQL(13k 별/주 330k 다운로드)
- pg: PostgreSQL(별 6k개/주별 520k 다운로드)
- sqlite3: SQLite(3k 별 / 120k 매주 다운로드)

각 라이브러리는 기본적으로 동일한 방식으로 작동합니다. 즉, 데이터베이스 자격 증명을 가져오고, 새 데이터베이스 인스턴스를 인스턴스화하고, 데이터베이스에 연결하고, 문자열 형식으로 쿼리를 전송하고, 결과를 비동기식으로 처리합니다.

다음은 `pg` 모듈을 사용하여 치킨 틱카 마살라를 요리하는 데 필요한 재료 목록을 얻는 간단한 예입니다.

### 중간 수준: 쿼리 작성기

이 레벨은 간단한 데이터베이스 드라이버 모듈과 본격적인 ORM 사이의 중간 레벨입니다. 이 계층에서 동작하는 가장 주목할 만한 모듈은 크넥스이다. 이 모듈은 몇 가지 다른 SQL 방언에 대한 쿼리를 생성할 수 있습니다. 이 모듈은 앞서 언급한 라이브러리 중 하나에 따라 다릅니다. Knex와 함께 사용하려는 특정 라이브러리를 설치해야 합니다.

- knex: Query Builder(별 8,000개/주별 170,000개 다운로드)

Knex 인스턴스를 만들 때 사용하려는 방언과 함께 연결 세부 정보를 제공하고 쿼리를 시작할 수 있습니다. 작성한 쿼리는 기본 SQL 쿼리와 매우 유사합니다. 한 가지 좋은 점은 문자열을 연결하여 SQL을 형성하는 것보다 훨씬 편리한 방법으로 동적 쿼리를 프로그래밍 방식으로 생성할 수 있다는 것입니다(종종 보안 취약성을 도입함).

다음은 `knex` 모듈을 사용하여 치킨 틱카 마살라를 요리하는 데 필요한 재료 목록을 얻는 간단한 예입니다.

### 하이 레벨: ORM

이것은 우리가 고려할 가장 높은 수준의 추상화입니다. ORM을 사용할 때는 일반적으로 훨씬 더 많은 구성을 미리 수행해야 합니다. ORM의 요점은 이름에서 알 수 있듯이 관계형 데이터베이스의 레코드를 애플리케이션의 객체(일반적으로 항상은 아니지만)에 매핑하는 것입니다. 즉, 애플리케이션 코드에서 이러한 개체의 구조 및 관계를 정의하는 것입니다.

- 후속편: (별 16,000개 / 매주 270,000개 다운로드)
- 책장: Knex 기반 (별 5만 개 / 매주 23만 개 다운로드)
- 워터 라인: (별 5만 개 / 매주 20만 개 다운로드)
- 이의: Knex 기반 (별 3개 / 매주 20,000개 다운로드)

## Node.js와 함께 Secretize 사용

이 예에서는 가장 인기 있는 ORM인 Secretize에 대해 알아보겠습니다. 우리는 또한 우리의 원래 Postgre에서 대표되는 관계들을 모델링할 것이다.Secretize를 사용하는 SQL 스키마입니다. 다음은 Supecialize 모듈을 사용하여 치킨 틱카 마살라를 요리하는 데 필요한 재료 목록을 얻는 것과 동일한 예입니다.

## ORM이 정말 필요한가요?

이제 여러 추상화 계층을 사용하여 유사한 쿼리를 수행하는 방법에 대한 예를 보셨으니, ORM 사용을 주의해야 하는 세 가지 이유를 살펴보겠습니다.

### 1. 당신은 잘못된 것을 배우고 있어요.

많은 사람들이 기본 SQL(구조화된 쿼리 언어)을 익히는 데 시간을 들이고 싶지 않기 때문에 ORM을 선택합니다. SQL은 배우기 어렵고 ORM을 학습함으로써 우리는 단순히 두 개의 언어 대신 단일 언어를 사용하여 애플리케이션을 작성할 수 있다는 믿음이 종종 있다. 얼핏 보면 이게 버티는 것 같아요. ORM은 애플리케이션의 나머지 부분과 동일한 언어로 작성되지만 SQL은 완전히 다른 구문입니다.

그러나 이러한 사고방식에 문제가 있다. 문제는 ORM이 가장 복잡한 라이브러리를 나타낸다는 것입니다. ORM의 표면적은 매우 크고 그것을 안팎으로 배우는 것은 쉬운 일이 아니다.

특정 ORM을 배운 후에는 이러한 지식이 제대로 전달되지 않을 수 있습니다. 이것은 JS/Node.js와 같은 플랫폼 간에 전환할 경우 해당됩니다.NET. 그러나 Node.js를 사용하여 Supecialize와 Booksize와 같은 플랫폼 내에서 ORM을 다른 ORM으로 전환할 경우 이는 사실일 수 있습니다. 채식주의자인 모든 조리법 항목의 목록을 생성하는 다음 ORM 예제를 고려하십시오.

#### 속편:

#### 책장:

#### 워터 라인:

#### 이의:

간단한 읽기 작업에 대한 구문은 이러한 예들 사이에 크게 다르다. 여러 테이블을 포함하는 작업과 같이 수행하려는 작업의 복잡성이 증가함에 따라 ORM 구문은 구현마다 더욱 다양해집니다.

Node.js에만 최소 수십 개의 ORM이 있으며, 모든 플랫폼에는 최소 수백 개의 ORM이 있다. 이 모든 도구들을 배우는 것은 악몽이 될 것입니다!

다행스럽게도, 걱정할 SQL 방언은 거의 없습니다. 원시 SQL을 사용하여 쿼리를 생성하는 방법을 배우면 여러 플랫폼 간에 이 지식을 쉽게 전송할 수 있습니다.

### 2. 복잡한 ORM 호출은 비효율적일 수 있습니다.

ORM의 목적은 데이터베이스에 저장된 기본 데이터를 가져와서 응용프로그램 내에서 상호 작용할 수 있는 객체에 매핑하는 것입니다. 이것은 종종 ORM을 사용하여 특정 데이터를 가져올 때 비효율성을 동반한다.

예를 들어, 추상화 계층에 대한 섹션에서 처음 살펴본 쿼리를 생각해 보자. 그 질문에서, 우리는 단지 특정 레시피에 대한 재료와 재료의 목록을 원했습니다. 먼저 우리는 수작업으로 SQL을 작성하여 질의했습니다. 다음으로, 우리는 Query Builder, Knex를 사용하여 쿼리를 만들었습니다. 마지막으로, 우리는 ORM, Secretize를 사용하여 쿼리를 만들었습니다. 다음 세 가지 명령으로 생성된 쿼리를 살펴보겠습니다.

#### pg 드라이버로 직접 작성:

이 첫 번째 질문은 정확히 우리가 손으로 쓴 것입니다. 이것은 우리가 원하는 데이터를 정확하게 얻을 수 있는 가장 간결한 방법입니다.

이 쿼리 앞에 `EXPLANE`를 붙여서 Postgre로 보낼 때SQL 서버, 34.12의 비용 작업을 받습니다.

#### knex 쿼리 작성기를 사용하여 생성됨:

이 다음 쿼리는 대부분 우리를 위해 생성되었지만, Knex Query Builder의 명시적인 특성 때문에 우리는 출력이 어떻게 보일지에 대해 꽤 많은 기대를 가져야 한다.

가독성을 위해 제가 새 줄을 추가했습니다. 내 필기 예에서 일부 보조 형식과 불필요한 테이블 이름 외에 이러한 쿼리는 동일합니다. 실제로 EXPLANE 쿼리가 실행되면 34.12점으로 같은 점수를 받는다.

#### Secretalize ORM으로 생성:

이제 ORM에서 생성된 쿼리를 살펴보겠습니다.

가독성을 위해 제가 새 줄을 추가했습니다. 이 쿼리는 앞의 두 쿼리와는 많이 다릅니다. 왜 이렇게 다르게 행동하죠? 음, 우리가 정의한 관계 때문에, 시퀄라이즈는 우리가 요청한 것보다 더 많은 정보를 얻으려고 노력하고 있습니다. 특히, 우리는 그 요리에 속하는 재료에만 신경을 쓸 때 요리 자체에 대한 정보를 얻고 있습니다. EXPLANE에 따르면 이 질의의 비용은 42.32이다.

### 3. ORM은 모든 것을 할 수 없다.

일부 쿼리를 ORM 작업으로 표시할 수는 없습니다. 이러한 쿼리를 생성해야 할 때는 SQL 쿼리를 직접 생성하는 것으로 되돌아가야 합니다. 이는 ORM 사용량이 많은 코드베이스에 여전히 몇 개의 직접 작성된 쿼리가 산재해 있다는 것을 의미한다. 여기서 시사하는 바는 개발자가 이러한 프로젝트 중 하나를 작업함에 따라 ORM 구문과 일부 기본 SQL 구문을 모두 알아야 한다는 것입니다.

ORM에서 제대로 작동하지 않는 일반적인 상황은 쿼리에 하위 쿼리가 포함되어 있는 경우입니다. 제가 이미 데이터베이스에서 Dish #2에 대한 모든 재료를 구입했다는 것을 알고 있는 상황을 고려해 볼 때, Dish #1에 필요한 모든 재료를 구입해야 합니다. 이 목록을 가져오기 위해 다음 쿼리를 실행할 수 있습니다.

내가 아는 한, 이 쿼리는 앞에서 언급한 ORM을 사용하여 올바르게 표현될 수 없다. 이러한 상황을 극복하기 위해 ORM은 쿼리 인터페이스에 원시 SQL을 주입하는 기능을 제공하는 것이 일반적이다.

Secretize는 기본 데이터베이스 드라이버를 사용하는 것처럼 원시 SQL을 실행하는 `.query()` 메서드를 제공합니다. Booklooks와 Object ORM을 모두 사용하면 인스턴스화 중에 제공하는 원시 Knex 개체에 액세스할 수 있으며 이 개체를 쿼리 작성기 전원에 사용할 수 있습니다. Knex 개체에는 원시 SQL을 실행하는 .raw() 메서드도 있습니다. Secretize를 사용하면 Secretize.Literal() 방식도 제공되므로 Secretize ORM 호출의 다양한 부분에 원시 SQL을 삽입할 수 있습니다. 그러나 이러한 각 상황에서 특정 쿼리를 생성하려면 기본 SQL을 알아야 합니다.

## Node.js에서 쿼리 작성기 사용: 단점

낮은 수준의 데이터베이스 드라이버 모듈을 사용하는 것은 다소 매력적입니다. 수동으로 쿼리를 작성하므로 데이터베이스에 대한 쿼리를 생성할 때 오버헤드가 없습니다. 우리의 프로젝트가 의존하는 전반적인 의존도 또한 최소화된다. 그러나 동적 쿼리를 생성하는 것은 매우 지루할 수 있으며, 내 생각에는 간단한 데이터베이스 드라이버를 사용하는 것이 가장 큰 단점이다.

예를 들어 사용자가 항목을 검색할 때 기준을 선택할 수 있는 웹 인터페이스를 고려하십시오. 사용자가 입력할 수 있는 색상 등 하나의 옵션만 있는 경우 쿼리는 다음과 같을 수 있습니다.

```undefined
SELECT * FROM things WHERE color = ?;
```

이 단일 쿼리는 단순 데이터베이스 드라이버와 잘 작동합니다. 그러나 색상이 선택 사항이고 is_heavy라는 두 번째 옵션 필드가 있는 경우 고려하십시오. 이제 이 쿼리의 몇 가지 다른 순열을 지원해야 합니다.

```undefined
SELECT * FROM things; -- Neither
SELECT * FROM things WHERE color = ?; -- Color only
SELECT * FROM things WHERE is_heavy = ?; -- Is Heavy only
SELECT * FROM things WHERE color = ? AND is_heavy = ?; -- Both
```

하지만, 앞서 언급한 이유 때문에, 완전한 ORM은 우리가 도달하고 싶은 도구가 아닙니다.

이러한 상황에서는 쿼리 작성기가 상당히 좋은 도구가 됩니다. Knex에 의해 노출된 인터페이스는 기본 SQL 쿼리에 너무 가까워서 우리는 항상 SQL 쿼리가 어떻게 생겼는지 알 수밖에 없다. 이 관계는 TypeScript와 같은 것이 JavaScript로 변환되는 방식과 유사합니다.

생성 중인 기본 SQL을 완전히 이해하기만 하면 쿼리 빌드를 사용하는 것이 좋습니다. 이 도구를 하위 계층에서 발생하는 상황을 숨기기 위한 도구로 사용하지 마십시오. 단지 편의상 그리고 정확히 무엇을 하는지 아는 상황에서만 사용하세요. 생성된 쿼리가 실제로 어떻게 생겼는지 궁금한 경우 `Knex()` 인스턴스 호출에 디버그 필드를 추가할 수 있습니다. 이렇게 하면 다음과 같습니다.

사실, 이 게시물에 언급된 대부분의 라이브러리들은 실행 중인 호출을 디버깅하기 위한 일종의 방법을 포함하고 있다.

## 결론

데이터베이스 상호 작용을 추상화하는 세 가지 계층, 즉 로우 레벨 데이터베이스 드라이버, 쿼리 빌더 및 하이 레벨 ORM을 조사했습니다. 또한 생성되는 SQL 쿼리와 각 계층을 사용하는 경우의 절충점을 조사했습니다. 데이터베이스 드라이버를 사용하여 동적 쿼리를 생성하는 어려움도 여기에 포함됩니다.ORM의 복잡성, 그리고 마지막으로 쿼리 생성기를 사용할 때의 좋은 점.

읽어주셔서 감사드리며, 다음 프로젝트를 작성할 때 이 점을 반드시 고려하시기 바랍니다.

다음 명령을 실행하여 도커 컨테이너를 완전히 제거하고 컴퓨터에서 데이터베이스 파일을 제거할 수 있습니다.